In this section we prove that the set of total functionals on $\N$ definable in 
$\systemT$ and $\CTlambda$ are the same.

The inclusion from $\systemT$ and $\CTlambda$ is easy to prove.
For any type $T$ we can define a term $\Rec:T,(\N,T \rightarrow T)\rightarrow T$ such that
$\Rec(a,f,0) = a$ and $\Rec(a,f)(n+1) = f(n,\Rec(a,f,n))$, for all numeral $n \in \Num$.
The definition is $\Rec = \lambda a,f.\rec$ 
with $\rec = \cond (a,\lambda x^{\N}.f(x,\rec(x))) : \N \rightarrow T$.

The opposite inclusion, from $\CTlambda$ to $\systemT$, it has been proved by proof-theory for the
combinatorial version of circular $\systemT$. For $\CTlambda$, we will define instead an algorithm
taking an infinite term in  $\CTlambda$, described as a finite circular tree, 
and returning a term in $\systemT$. 

Our translation extends by a linear factor the size of the term: cyclic terms are simpler.
%Our translation can expand
%more than exponentially the size of the finite circular tree.

We need a notion of extensional equality for  functionals on $\N$ of $\CTlambda$ and of $\systemT$. 

We define $t \sim_{\beta,\rec} u$ if and and only if $t, u \in \systemT$ and $t,u$ have the same type
and for some $v \in \systemT$: $t \reduces_{\beta,\rec} v$ and $t \reduces_{\beta,\rec} v$
normal forms of type $\N$ if and only if they normalize to the same numeral.

We define an equivalence relation (in fact and extensional equality) 
$\sim_{\systemT}$ on $\systemT$, by induction on the type 


\begin{definition}[An extensional equality on $\systemT$]
Assume $t,u \in \systemT$.
\begin{enumerate}
\item
If $t,u:\N$ and $t,u$ are closed then we set: 
$(t \sim_{\systemT} u) \Leftrightarrow  (t \sim_{\beta,\rec} u)$.
\item
If $t,u:A,\vec{A}\rightarrow\N$ and $t,u$ are closed then we set: 
$(t \sim_{\systemT} u) \Leftrightarrow  
\forall a \in \systemT. (a:A), (\mbox{ $a$ closed}) \Rightarrow (t(a) \sim_{\systemT} u(a))$.
\item
If $t,u:\vec{A}\rightarrow\N$ and $\FV(t), \FV(u) \subseteq \vec{x}$ then we set:
$$
(t \sim_{\systemT} u) 
\Leftrightarrow  
\forall \vec{a} \in \systemT. 
(\vec{a}:\vec{A}), (\mbox{ $\vec{a}$ closed})  
\Rightarrow 
(t[\vec{a}/vec{x}] \sim_{\systemT} u[\vec{a}/vec{x}])
$$
\end{enumerate}
\end{definition}

Then we can consider $\systemT$ as a structure $(\systemT/\sim_{\systemT}, 0, \Succ, \ap)$
with natural numbers, functionals and extensional equality. 
In the same way we define an equivalence relation on terms of $\CTlambda$ which denote functionals
(whose type $T$ only include the atomic type $\N$). 


\begin{definition}[An extensional equality on $\CTlambda$]
Assume $t,u \in \CTlambda$.
\begin{enumerate}
\item
If $t,u:\N$ and $t,u$ are closed then we set: 
$(t \sim_{\CTlambda} u) \Leftrightarrow  (t \sim_{\CTlambda} u)$.
\item
If $t,u:A,\vec{A}\rightarrow\N$ and $t,u$ are closed then we set: 
$(t \sim_{\CTlambda} u) \Leftrightarrow  
\forall a \in \CTlambda. (a:A), (\mbox{ $a$ closed}) \Rightarrow (t(a) \sim_{\CTlambda} u(a))$.
\item
If $t,u:\vec{A}\rightarrow\N$ and $\FV(t), \FV(u) \subseteq \vec{x}$ then we set:
$(t \sim_{\CTlambda} u) 
\Leftrightarrow  
\forall \vec{a} \in \CTlambda. 
(\vec{a}:\vec{A}), (\mbox{ $\vec{a}$ closed})  \Rightarrow (t[\vec{a}/vec{x}] \sim_{\CTlambda} u[\vec{a}/vec{x}])$.
\end{enumerate}
\end{definition}

Our goal is now to prove that there is a partial isomorphism from the types of $\N$-functionals in 
$(\CTlambda/\sim_{\CTlambda}, 0, \Succ, \ap)$ to the entire
$(\systemT/\sim_{\systemT}, 0, \Succ, \ap)$.
We ignore types of $\CTlambda$ including type variables, they have no corresponding in $\systemT$.

For each $\N$-functional type $T$ we define a map $\phi_T$ from terms of type $T$ of $\CTlambda$
to terms of type $T$ of $\systemT$. We abbreviate $\phi_T$ with $\phi$ and we require:

\begin{enumerate}
\item
If $t \sim_{\CTlambda} u$ then $\phi(t) \sim_{\systemT} \phi(u)$

\item
If $t: A \rightarrow B$, $u:A$ then $\phi(t(u)) \sim_{\systemT} \phi(t)(\phi(u))$

\item
$\phi(0) \sim_{\systemT} 0$ and
$\phi(\Succ(t)) \sim_{\systemT} \Succ(\phi(t))$

\end{enumerate}

We require the following property of $\systemT$: we can define terms of $\systemT$ by $n$
simultaneous lexicographic inductions. If $\vec{n} \in \N^m$ are numeral, we define 
$\vec{n} \lexicographic{} \vec{m}$ if and only if $\vec{n} \not = \vec{m}$ and for the first $i \in [1,m]$
such that $n_i \not = m_i$ we have $n_i +1 = m_i$. 
If $T=\vec{A} \rightarrow \N$ is a functional type we define
$0_T = \lambda \vec{x}:\vec{A}.0$. If $f:T$ we define $f \restr  \vec{x}$
as the restriction of $f_i$ to the set of $\vec{y} \lexicographic{} \vec{x}$, 
extended by the dummy value $0_T$:
\begin{center}
 $(f \restr  \vec{x})(\vec{y}) = f(\vec{y})$ if $\vec{y} \lexicographic{} \vec{x}$ 
\ \ \ 
and 
\ \ \ 
$(f \restr  \vec{x})(\vec{y}) = 0_T$ otherwise
\end{center}


\begin{proposition}[Simultaneous lexicographic induction in $\systemT$]
Assume $\vec{x}:\N^m$,
and that we have any equation list in $\systemT$, in the meta-variables $f_1, \ldots, f_n$:
$$
f_i(\vec{x}) 
\ \ \ 
\sim_{\systemT} 
\ \ \ 
F_i(\vec{x}, f_1 \restr  \vec{x}, \ldots, f_n \restr  \vec{x})
\ \ \ 
 : 
\ \ \ 
T_i
$$
This  equation list has solutions 
$
f_1:\N^m \rightarrow T_1, 
\ldots, 
f_n:\N^m \rightarrow T_n
$ 
in $\systemT$ and we can compute them. 
\end{proposition}


Assume $t:T$ is a cyclic term, represented as a cyclic tree with node $t_1$, \ldots, $t_n$.
We translate it to a term of $\systemT$, obtained by solving an equation list whose meta-variables
are the nodes the cyclic tree, with $\vec{x} = \vec{y},c$,
and $\vec{y}$ the union of the $\N$-arguments of each node,
and $c$ a variable used as a counter. The counter 
$c$ starts from $n$, the number of nodes, and decreases
of $1$ unit in each recursive call. 
Within $n$ recursive calls, one or more value of $\vec{y}$ decreases by $1$,
while all other values stay the same. In this case the varabile $c$ is reset to $n$: $c$ is the only
variable which can increase during computation.


%
%This is a first draft about how to do it.
%
%%%%%%%%%%%%%%
% % TO BE IMPROVED
%%%%%%%%%%%%%%
%
%\begin{enumerate}
%
%\item
%We first move all nodes to a context with the same number on type $\N$ variables, 
%by adding dummy variables and dummy arguments.
%This operation preserves regularity and global trace condition.
%Now $t_1$, \ldots, $t_n$ all have context $\Gamma$ and type $A$.
%
%\item
%We merge all buds into the same term, defined by some $u$ such that $u(i)=t_i$, for $i=1, \ldots, n$,
%and $u(i)=$ some dummy term of type $A$ otherwise. We replace each $t_i$ with $u(i)$, 
%for $i=1, \ldots, n$.
%This operation preserves regularity and global trace condition.
%Now we have $n$ buds, all are the same $u$ with context $\Gamma$ and type $\N \rightarrow A$.
%Each bud $b$ defines a partial bijection between the occurrence of $\N$ in its context and type
%$\Gamma \vdash \N \rightarrow A$, and the occurrences of $\N$ in the context and type
%$\Gamma \vdash \N \rightarrow A$ of its companion. 
%We extend this partial bijection to any total bijection $\tau$, depending on the but $b$.
%
%\item
%We close the partial bijections defined by each bud by composition. The number of partial 
%bijections can grow in an exponential  way.
%
%\item
%Assume we have $m$ occurrences of $\N$ inside the context and type 
%$\Gamma \vdash \N \rightarrow A$ of $u$.
%We fix a permutation $\sigma:\{1, \ldots, m\}$ 
%and we label them by variables $x_1, \ldots, x_n$ of $\systemT$,
%with $x_i$ label of the argument with type $\N$ and number $i$.
%We will define a translation $t^\sigma \in \systemT$ of  $t \in \CTlambda$.
%
%\item
%All traces move from $u$ to any of the occurrences of $u$ inside $u$. 
%Some traces of some $\N$
%in $\Gamma \vdash \N \rightarrow A$ disappear, some other are moved to some other $\N$,
%in an injective way. Two traces never merge.
%We label each trace in the bud $u$ with the name $x_i$ of the corresponding trace, if any.
%All those corresponding to no trace are labeled at random using the remaining variable names.
%
%At least one trace progresses, otherwise by repeating infinitely many times this step we would get a
%path with no progressing trace. The same is true for any combination of one or more movements
%from $u$ to $u$. 
%
%%After $m$ movements to any $u$ inside $u$, 
%%each of the $m$ traces either disappeared or cycles. After $m!$ steps, all
%%cycles are back to their original point. 
%%
%%All traces are now restarted or move from one $\N$ to the same $\N$, with or without progression.
%
%\item
%At least one trace $x_i$ progresses and it is not erased by any other trace. Otherwise we could follow a path
%in which each progress is erased in some new step, and so there is no infinite progressing trace.
%We use this trace as the main variable $x_i$ of the recursion. In all steps, either $x_i$ is constant or decreases,
%and in at least one case it decreases. In all cases in which $x_i$ decrease we use primitive
%recursion on $x_i$ in $\systemT$, as main variable. 
%In all other case, $x_i$ is not removed, therefore it stays the same. 
%We isolate the main variable $x_j$ of the recursion for these steps, it is progressing therefore $j \not = i$.
%We use primitive recursion on $x_j$: this is the second variable of primitive recursion. 
%We continue in this way and we define a primitive recursion in $\systemT$, with pairwise distinct 
%indexes $x_{i_1} = x_i$, $x_{i_2} = x_j$, \ldots, $x_{i_k}$ for some $k \ge 1$. We extend 
%$x_{i_1}, \ldots, x_{i_k}$ to $x_{i_1}, \ldots, x_{i_n}$ in a random way: we defined in this way a
%permutation $\sigma$ on $\{1, \ldots, m\}$ by $\sigma(j) = i_j$ for $j \in \{1, \ldots, m\}$
%We define in this way a closed primitive recursive term 
%$\lambda \vec{x}.t^\sigma \in \systemT$. Each bud $u$
%defining a permutation $\tau$ is replaced by $\exch_{\tau}(f)$.
%The term $\exch_\tau \in \systemT$ applies the permutation $\tau$ to the arguments of $f$,
%and during the recursive call $f$ is replaced by $\lambda \vec{x}.u^\sigma$.
%\end{enumerate}
%
%We claim that the infinite term $t^\sigma \in \systemT$ 
%is equivalent to the cyclic recursive term $t \in \CTlambda$ we started from.
