% lmcs, 2018.5.2, 2019.9.9, 2020.2.10



\newif\ifdraft \draftfalse
\drafttrue % put % for lipics


\long\def\Stefano#1{{{\color{red}{SB: #1}}}}
\long\def\Makoto#1{{{\color{blue}{MT: #1}}}}
\long\def\Daisuke#1{{{\color{green}{DK: #1}}}}

\ifdraft

\documentclass{article}
\usepackage{mystyle}
\A4page
\usepackage{tikzpicture}

\else

\documentclass{lmcs}
\usepackage{hyperref}
%\usepackage{amsmath}heoremstyle{plain}\newtheorem{satz}[thm]{Satz} %\crefname{satz}{Satz}{\Succ    atze}

\fi

\usepackage{mymath,proof,latexsym}
\usepackage{xcolor}
\usepackage[pdftex,outline]{contour}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% AGGIUNGO TEOREMA LEMMA PROPOSIZIONE COROLLARIO PROVA % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


\begin{document}
\sloppy 
\hbadness=10000
\vbadness=10000

\input{macro}
\input{title}



\section{Introduction}
We will introduce $\LAMBDA$, a set of infinite $\lambda$-terms with a circular syntax.
The types of $\LAMBDA$ are: the atomic type $\N$, 
possibly type variables $\alpha, \beta, \ldots$, and all types $A \rightarrow B$ for any types $A$, $B$. 
Type variables are only used to provide examples and they play a minor role in our paper.

The terms of $\LAMBDA$  are all possibly infinite trees representing expressions defined with 
$0$,$\Succ $,$\ap$ (application), 
variables $x^T$ (with a type superscript $T$),  $\lambda$ (the binder for defining maps), 
and $\cond$, the arithmetic conditional (i.e., the test on zero). 
If we have no type variables, then the trees in $\LAMBDA$ represent partial functionals on $\N$, 
provided we add reduction rules transforming closed terms of type $\N$ in notations for natural numbers.

%19:42 19/04/2024

In this paper will consider two sets of terms: 
\begin{enumerate}
\item
the set $\CTlambda$ of well-typed terms in
a circular syntax, which are equivalent to the set of terms in G\"{o}del system $\systemT$.  
\item
The set of terms $\GTC$, satisfying a condition called global trace condition, which are possibly non-recursive
terms used to provide semantics for  $\CTlambda$
\end{enumerate}
We introduce more sets of terms required as intermediate steps in the definition of $\GTC$ and $\CTlambda$.

\begin{enumerate}
\item
 $\WTyped \subseteq \LAMBDA$, the set of well-typed terms, is the
of terms having a unique type
\item
$\Reg$ is the set of terms of $\LAMBDA$ which are regular trees (i.e., having finitely
many subtrees). They are possibly infinite terms which are finitely presented 
by a finite graph possibly having cycles.
\item 
$\GTC \subseteq \WTyped$ will be defined as the set of well-typed circular 
$\lambda$-terms satisfying the global trace condition and regular. 
Terms of $\GTC$ denote total functionals. 
\end{enumerate}

We will prove that $\CTlambda$ is a decidable subset of $\Reg$.
$\CTlambda$ is a new circular version of G\"{o}del system $\systemT$. 
Differently from all previous circular versions of $\systemT$, our system $\CTlambda$
uses binders instead of combinators. 
The circular syntax has the advange of writing much shorter terms while preserving decidability
of termination.
Besides, by introducing a circular syntax with binders, we hope to provide 
a circular syntax more familiar to researchers working in the field of Type Theory.
\\

We will prove the expected results for the circular syntax $\CTlambda$:
strong normalization for reductions not in the right-hand side of any $\cond$ and Church-Rosser. 
We will prove normalization in the limit if we use reductions which are ``fair'':
fair reductions can reduce \emph{inside} the right-hand side of some $\cond$, but they never forget entirely 
the task of reducing \emph{outside} all such subterms.

Eventually, we will prove that the closed terms $\CTlambda$ (those without free variables)
represent exactly the total computable functionals definable in G\"{o}del system $\systemT$.


%14:57 17/04/2024
%21:08 19/04/2024


\section{The set of infinite $\lambda$-terms}
We define the set $\LAMBDA$ of infinite circular terms, the subset $\WTyped$
of well-typed terms and a reduction relation for them.

\begin{definition}[Types of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
The types of $\LAMBDA$ are: the type $\N$ of natural numbers, an infinite list 
$\alpha,\beta,\ldots$ of type variables, and with $A,B$ also  $A \rightarrow B$.
We call them simple types, \emph{types} for short. 

\item 
$\Type$ is the set of simples types.

\item
We suppose be given a set $\var$ of all pairs $x^T$ of a variable name $x$ and a type $T \in \Type$.
\end{enumerate}
\end{definition}

We write $\Nat$ for the set of natural numbers: 
all $n \in \Nat$ are represented in $\LAMBDA$ by some 
expression of type $\N$ which we call a \emph{numeral}.

We code (countable) trees on a set $I$ as any set $T$ of non-empty lists $(i_1, \ldots, i_n)$
of elements of $I$ closed by non-empty prefix and having a minimum $(i)$, which we call the root of $T$.
As usual, a leaf of $T$ is a maximal element of $T$. A subtree $U \subseteq T$ is the set of nodes of
$T$ extending some $l \in T$. $U$ is coded by $l$ in $T$. We write $\nil=()$ for the empty list
and $(i_1, \ldots, i_n) \conc i$ for $(i_1, \ldots, i_n,i)$. Any node $m \in T$ has the form 
$m = l \conc i$ for some list $l$, with $l \in T$ if $m$ is not the root and $l=\nil$ if $m$ is the root.

Terms of $\LAMBDA$ are trees.


\begin{definition}[Terms of $\LAMBDA$]
The terms of $\LAMBDA$ 
are all possibly infinite trees we can define with $x^T \in \var$ (leaf), 
$\lambda x^T.t$ (node with child $t$), 
$\ap(t,u)$ (node with children $t$, $u$), $0$ (leaf), $\Succ(t)$ (node with child $t$), 
$\cond(f,g)$ (node with children $f$, $g$).
\end{definition}
 
More formally, a term is any set of finite non-empty lists on the set 
$I=\{x^T, \lambda x^T | x^T \in \var\} \cup \{0, \Succ, \ap, \cond\}$
closed by non-empty prefix, having a minimum, and whose maximal elements are all of the form $x^T$
or $0$. 

We define the sub-term relation.

%11:55 22/04/2024

\begin{definition}[Sub-terms of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
A subterm of $t$ is any subtree of $t$, coded by some node of $t$.

\item
We call the child $t$ of a node $u$ any immediate sub-term of $u$.

\item
We write $\SubTerm(t)$ for the (finite or infinite) set of subterms of $t$. 
They are coded by the nodes of $t$. 

\item
$\Reg$ is the set of terms $t \in \LAMBDA$ such that $\SubTerm(t)$ is finite.
We call the terms of $\Reg$ the \emph{regular terms}.

\item
We write $\Tree(t)$ for the tree of all chains
$(t_1, \ldots, t_n)$, with $t_1=t$ and $t_{i+1}$ immediate subterm of $t_i$ for all $(i+1) \le n$.

\item
When $t = \Succ ^n(0)$ for some natural number $n \in \Nat$
we say that $t$ is a numeral. We write $\Num$ for the set of numeral.

\end{enumerate}
As usual, we abbreviate $\ap(t,u)$ with $t(u)$. 
\end{definition}

We use two different names for the operation $\ap(t,u)$: 
we call it $\ap$ when $u$ is not a variable and $\apvar$ when $u$ is a variable. 

$\Num$ is the representation inside $\LAMBDA$ of the set $\Nat$ of natural numbers.
All numeral are finite terms of $\Lambda$. 
All finite well-typed typed $\lambda$-terms 
we can define with the rules above are finite terms of $\LAMBDA$.
Regular terms can be represented by the subterm relation restricted to $\SubTerm(t)$:
this relation defines a graph with possibly cicles.


An example of regular term: the term $t = \cond(0,t)$. 
The set $\SubTerm(t)=\{t,0\}$ of subterms  of $t$ is finite, therefore $t$ is a regular term.
However, $\Tree(t)$ is an infinite tree (it includes itself as a subtree). 
The finite branches of $\Tree(t)$ are all $(t,t,t,\ldots,0)$, the unique infinite branch of $\Tree(t)$
is $(t,t,t,\ldots)$. 

In order to define the type of an infinite term, we first 
define contexts and sequences for any term of $\LAMBDA$.

%13:32 22/04/2024

\begin{definition}[Contexts of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
A  context of $\LAMBDA$ is any finite list $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ 
of pairwise distinct variables, each assigned to its $A_1, \ldots, A_n \in \Type$. 

\item
We denote the empty context with $\nil$. We write $\Ctxt$ for the set of all contexts.

\item
A sequent is the pair of a context $\Gamma$ and a type $A$, which we write as $\Gamma \vdash A$.
We write $\Seq = \Ctxt \times \Type$ for the set of all sequents.

\item 
A typing statement is the list of a context  $\Gamma$, a term $t$ and a type $A$, 
which we write as $\Gamma \vdash t:A$.
We write $\Stat = \Ctxt \times \LAMBDA \times \Type$ for the set of all typing statements.

\item
We write $\FV(\Gamma) = \{ {x_1}^{A_1}, \ldots, {x_n}^{A_n} \}$.
We say that $\Gamma$ is a context for $t \in \LAMBDA$ and we write $\Gamma \vdash t$ 
if $\FV(t) \subseteq \FV(\Gamma)$.

\item
If $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ ,
$\Gamma' = (x'_1:A'_1, \ldots, x'_n:A'_{n'})$ are context of $\LAMBDA$, then we
write 
\begin{enumerate}
\item
$\Gamma \subseteqsim \Gamma'$ if for all $(x^A:A)$: if $(x^A:A) \in \Gamma$ then 
$(x^A:A)\Gamma'$
\item
$\Gamma \sim \Gamma'$ if for all $(x^A:A)$: $(x^A:A) \in \Gamma$ if and only if
$(x^A:A)\Gamma'$
\end{enumerate}


\item
If $\Gamma$ is a context of $\LAMBDA$, then $\Gamma\setminus\{x^T:T\}$ is the context obtained
by removing $x_i^{A_i}:A_i$ from $\Gamma$ if $x_i^{A_i}=x^T$. 
If $x \not \in \FV(\Gamma)$ then $\Gamma\setminus\{x^T:T\} = \Gamma$.

\end{enumerate}
\end{definition}

We have $\Gamma \subseteqsim \Gamma'$ if and only if
if there is a (unique) map $\phi:\{1,\ldots,n\} \rightarrow \{1,\ldots,n'\}$
such that $x_{i}=x'_{\phi(i)}$ and $A_{i}=A'_{\phi(i)}$ for all $i \in \{1,\ldots,n\}$.
We have  $\Gamma \sim \Gamma'$ if and only if  $\Gamma \subseteqsim \Gamma'$
and  $\Gamma \supseteqsim \Gamma'$ if and only if $\Gamma$, $\Gamma'$ are permutation
each other if and only if the map $\phi$ above is a bijection.


%12:38 17/04/2024
%15:37 17/04/2024

From the context for a term we can define a context for each subterm of the term.
A context is a list of type assignment to variables: our variables already have a type superscript,
so a type assignment is redundant for our variables (not for our terms).
Yet, we add an assignment relation $x^T:T$ for uniformity with the notation $x:T$ 
in use in Type Theory.

%21:26 19/04/2024

%\begin{definition}[Inherited Contexts of $\LAMBDA$]
%
%Given any context $\Gamma$, any $t \in \Lambda$ and any subterm chain 
%$\pi = (t_1, \ldots, t_n) \in \Tree(t)$, we define a unique inherited context for $t_n$ in $\pi$.
%The inherited context is obtained by repeatedly adding $x^T:T$ to the context whenever we
%cross a term $t_i = \lambda x^T.u_i$, while simultaneously removing $x^T:T$ from the previous
%context, if it was there.
%%08:00 20/04/024
%
%\begin{enumerate}
%
%\item
%$t$ has inherited context $\Gamma$.
%
%\item
%Any binder on $x$ subtracts the variable $x$ from the context of its \emph{last} argument:
%if $t = \lambda x^T.u, \cond(f,g)$ has inherited context $\Delta$, 
%then $u$ and $g$ have context $\Delta \setminus \{x^T:T\}, x^T$, 
%while $f$ has  inherited context $\Delta$.
%
%\item
%In any other case the context of a term and of the immediate subterm are the same:
%ff $t=\Succ(u), f(a)$ have inherited context $\Delta$,
% then $u,f,a$ have  inherited context $\Delta$.
%\end{enumerate}
%We abbreviate \emph{`` inherited context from $\Gamma$''} with \emph{context}
%when $\Gamma$ is fixed.
%\end{definition}



%The scope of the binder $\lambda x^T.t$ is $t$.
%The scope of the binder $\cond(f,g)$ is $g$ ($f$ is \emph{not} in the scope of $\cond(f,g)$).

We define typing rules for terms of $\LAMBDA$ and the subset $\WTyped$ of well-typed terms.
We consider a term well-typed if typing exists and it is unique for the term and for all its subterms.

The typing rules are the usual ones but for %the conditional binder $\cond$, and for 
a fresh rule $\apvar$
for typing the application $t(x^T)$ of a term  to a variable $x^T$. 
%$\apvar$ corresponds to an $\eta$-expansion and it introduces a global variable name $x^T$
%for the first argument of $t$. 
%As we said, 
$\apvar$ is but the particular case of $\ap$ rule when the argument is a variable of the context.
We prefer to use a separate name for $\apvar$ 
because of the special role that $\apvar$ has in this paper for making easier to decide the termination of
rewriting.
We reserve the name $\ap$ for the typing rule of an application 
$t(u)$ of a term  to a non-variable $u$.

 Remark that we introduced a unique \emph{term notation}
for application: we write $\ap(t,u)$ no matter if $u$ is a variable or not.

%We have a single structural rule  $\struct_f$, which can be used for:
% weakening, variable permutation and variable renaming. 
We have a a single structural rule $\weak$ for extending a context $\Gamma$ to a context 
$\Gamma' \supseteqsim \Gamma$. When $\Gamma' \sim \Gamma$ ($\Gamma'$, $\Gamma$
are permutation each other), the rule $\weak$ can be used for variable permutation.
Variable renaming for a term $t[\vec{x}]$ can be obtained by writing 
$(\lambda \vec{x}.t[\vec{x}])(\vec{x'})$. 
Therefore we do not assume having a primitive rule for it.


\begin{definition}[Typing rules of $\LAMBDA$]
Assume $\Gamma = {x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_1$ is a context. 
%$\Delta = y_1:B_1, \ldots, y_n:B_m$ are sequents of length $n$, $m$ respectively. Suppose
%$f:\{1, \ldots, n\} \rightarrow \{1, \ldots, m\}$ is any injection, compatible with types
%in $\Gamma$, $\Delta$: we assume $A_i = B_{f(i)}$ for all $1 \le i \le n$.

\begin{enumerate}
%\item
%$\struct_f$-rule.
%If $t: \Gamma \vdash T$ then $t[ y_{f(1)}/x_1, \ldots,  y_{f(n)}/x_n]:\Delta \vdash T$
\item
A rule is a list of $n+1$ typing statements: 
$\Gamma \vdash t_1:A_1, \ldots, \Gamma \vdash t_n:A_n, \Gamma \vdash t : A$.
The first $n$ sequents are the premises of the rule, the last sequent is the conclusion of the rule.
\item
We read the rule above: \emph{``if $\Gamma \vdash t_1:A_1, \ldots, \Gamma \vdash t_n:A_n$
then $\Gamma \vdash t : A$"}.
\end{enumerate}

We list the typing rules of $\LAMBDA$.

\begin{enumerate}

\item
$\weak$-rule (Weakening).
If $\Gamma \vdash t:T$ and $\Gamma \subseteqsim \Gamma'$
then $\Gamma' \vdash t : T$

\item
$\var$-rule.
If $x^A \in \Gamma$ then $\Gamma \vdash x^A:A$.

\item
$\ap$-rule.
If $\Gamma \vdash f:A \rightarrow B$ and $\Gamma \vdash a:A$
and $a$ is \emph{not} a variable then $\Gamma \vdash f(a) : B$.

\item
$\apvar$.
If $\Gamma \vdash f: A \rightarrow B$ and  $(x^A:A)\in  \Gamma$
then $\Gamma \vdash f(x^A) :  B$.

\item
$\lambda$-rule.
If $\Gamma, x^A:A \vdash b: B$
then $ \Gamma \vdash \lambda x^A.b :A \rightarrow B$.

\item
$0$-rule.
$\Gamma \vdash 0: \N$

\item
$\Succ$-rule.
If $\Gamma \vdash t:\N$ then $\Gamma \vdash \Succ (t):\N$.

\item
$\cond$-rule.
If $\Gamma \vdash  f :T$ and  $\Gamma \vdash g : \N \rightarrow T$ 
then $\Gamma \vdash \cond(f,g) : \N \rightarrow T$.
\end{enumerate}
We abbreviate $\nil \vdash  t:A$ ($t:A$ in the empty context) with $\vdash t:A$. 
We write the set of rules of $\LAMBDA$ as
$$
\Rule = 
\{r \in \Seq \cup \Seq \cup \Seq^2 | r \mbox{ instance of some rule of }\LAMBDA\}
$$
\end{definition}

\begin{proposition}[Rules and subterms]
\label{proposition-rules-subterms}
Assume $r, r' \in \Rule$ have conclusion $\Gamma \vdash t:A$, $\Gamma' \vdash t':A'$
respectively, and $r, r\not = \weak$.
\begin{enumerate}
\item
If $\Gamma \vdash t:A = \Gamma' \vdash' t':A'$ then $r = r'$.
\item
If the premises of $r$ are some $\Gamma_1 \vdash t_1:A_1, \ldots, \Gamma_n \vdash t_n:A_n$,
then the list of immediate subterms of $t$ is exactly $t_1, \ldots, t_n$.
\end{enumerate}
\end{proposition}

From the typing rules we define the proofs that a term is well-typed. 
Proofs are trees on the set $\Rule$, each node is associated to a rule. 
We forbid applying infinitely many consecutive weakening rules. The reason is that we can prove
any typing statement $\Gamma \vdash t:A$ by infinitely many consecutive weakening rules.

Therefore eventually any branch includes a non-weakening rule after finitely many weakening rules.
Any finite composition of weakening rules can be contracted to one weakening rule, 
therefore we can assume that 
weakening and non-weakening rules alternate. By Prop. \ref{proposition-rules-subterms}
non-weakening rules are uniquely determined by 
their conclusion $\Gamma \vdash t:A$, and have assumptions $\Gamma_1 \vdash t_1:A_1$, \ldots,
$\Gamma_n \vdash t_n:A_n$, where $t_1, \ldots, t_n$ exactly the immediate subterms of $t$.
Therefore we can further simplify the notion of proof to
a decoration $\theta$ of the subterm tree by sequents. Any branch $\pi \conc u$ decorated
with $\theta(\pi \conc u) = \Delta \vdash B$ 
represents a rule $r \not = \weak$ of conclusion $\Delta \vdash u:B$.
The rule $r$ is possibly followed by a single weakening inferring some assumption of the father node  
$\theta(\pi)$, and inferring the conclusion of the proof if $\pi= \nil$.

This is the formal definition of proof.

\begin{definition}[Well-typed term of $\LAMBDA$]
Assume $\Pi:\Tree(t) \rightarrow \Rule$
 is an assignment of one non-weakening rule $r = \Pi(\pi)$ of conclusion
some $\Delta \vdash u : B$ for each
chain $\pi$ of immediate subterms from $t$ to $u$. 
Assume $\Gamma$ is a context of $t$ (i.e, $\FV(t) \subseteq \Gamma$) and $A \in \Type$ 

Then we write $\Pi: \Gamma \vdash t:A$, and we say that $\Pi$ is a proof of $\Gamma \vdash t:A$ if:

\begin{enumerate}

\item 
$\Pi((t))$ is a rule of conclusion $\Gamma' \vdash A$ for some $\Gamma' \subseteqsim \Gamma$.

\item
Assume that
\begin{enumerate}
\item
$\pi$ is any subterm chain from $t$ to $u$
\item
$u_1, \ldots, u_m$ are the immediate subterms of $u$
\item
$r_1 = \Pi(\pi \conc u_1), \ldots, r_n = \Pi(\pi \conc u_n$ are rules of conclusion 
$\Delta'_1 \vdash B_1$, \ldots, $\Delta'_n \vdash B_n$.
\item
$r=\Pi(\pi)$ is a rule of premises $\Delta_1 \vdash B_1$, \ldots, $\Delta_n \vdash B_n$
\end{enumerate}
Then $\Delta'_1 \subseteqsim \Delta_1$, \ldots, 
$\Delta'_n \subseteqsim \Delta_n$.
\end{enumerate}

\end{definition}

Using all notations above, we require that the following weakening rules are correct:
\[
 \infer[r]
 {  \Delta \prove u : B  }
   {
       {   \infer[\weak]
          {\Delta_1  \prove u_1:B_1}
          {\Delta'_1 \prove u_1:B_1}
       }
       { \ \ \ \ldots \ \ \ }
	  {  \infer[\weak]
          {\Delta_n  \prove u_1:B_1}
          {\Delta'_n \prove u_1:B_1}
       }
   }
\]
and
\[
 \infer[\weak]
 {  \Gamma \prove t : A  }
   {
     \Gamma' \prove t : A 
   }
\]
Eventually we define the well-typed terms of $\LAMBDA$.

\begin{definition}[Well-typed term of $\LAMBDA$]
\mbox{}
\begin{enumerate}
\item
$\Gamma \vdash t:A$ is true if and only if $\Pi:\Gamma \vdash t:A$ for some $\Pi$.
\item
$t \in \LAMBDA$ is well-typed if and only if $\Pi:\Gamma \vdash t:A$ for some \emph{unique} $A$
and some context $\Gamma \supseteqsim \FV(t)$.
\item
$\WTyped$ is the set of well-typed $t \in \LAMBDA$.
\end{enumerate}
%A proof $\Pi:\Gamma \vdash  t :T$ is canonical if all $\weak$-rules
%\begin{enumerate}
%\item
% either follow some $\lambda$-rule for a term $\lambda x^T.b$, and they introduce $x^T$ in the context,
%\item
%or follow some $\cond$-rule for a term $\cond(f,g)$, and and they introduce $x^\N$ in the context,
%\end{enumerate}
\end{definition}

We provide some examples of well-typed and not well-typed terms.
%23:30 23/04/2024
Some term in $\LAMBDA$ has no type, like the application $0(0)$ of the non-function $0$. 
Some term in $\LAMBDA$ has more than one type.
For instance if $t=\cond(t,t)(0)$ we can prove $\vdash t:A$ for all types $A \in \Type$. 
The subterms of $t$ are $\{t, \cond(t,t), 0\}$ and a proof $\Pi:\vdash t:A$ 
is defined by $\Pi(\pi \conc t)=\vdash A$, $\Pi(\pi\conc\cond(t,t)) = \N \rightarrow A$ 
and $\Pi(\pi \conc 0)=\N$.
%09:06 24/04/2024
A term with two types has the leftmost branch infinite, as it is the case for $t$ above.
We will prove that if \emph{all} subterms of a term have the leftmost branch finite, then the term 
has at most one type. If the term is also regular then we can decide if the typing proof exists and 
if it exists we can compute it (in quadratic time).
Well-typed terms are closed by substitution.

%10:26 20/04/2024

Our goal is to provide a set of well-formed term for $\LAMBDA$ and interpret them as partial functionals.
Some terms, those satisfying the global trace condition (to be introduced later) will be total functionals.
Our first step is to provide reduction rules for $\LAMBDA$.

%18:14 27/03/2024

\begin{definition}[reduction rules for $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
$\reduces_\beta$: $(\lambda x^A.b)(a) \reduces_\beta b[a/x]$

\item 
$\reduces_\cond$: $\cond(f,g)(0) \reduces_\cond f$ and
$\cond(f,g)(\Succ (t)) \reduces_\cond g(t)$.

\item
$\reduces$ is the context and transitive closure of $\reduces_\beta$ and $\reduces_\cond$

\item
$t \sim u$ if and only if there is some $v \in \LAMBDA$ such that $t \reduces v$ and $u \reduces v$.

\item
The $\cond$-depth of a subterm path $(t_1, \ldots, t_n) \in \SubTerm(t)$ 
is the number of $i \in [1,n[$ such that $t_i = \cond(f,g)$ and $t_{i+1} = g$
(such that $t_n$ occurs in the right-hand-side of a $\cond$).

\item
We say that $t \reduces_\safe u$, or that $t$ reduces safely to $u$,  
if we only reduce in a subterm path of $\cond$-depth $=0$.
%We call \emph{unsafe} a reduction inside any $\cond(f,g)$.

\item
A term is safe-normal if all its redexes (if any) have $\cond$-depth $>0$.
\end{enumerate}
\end{definition}

%09:19 24/04/2024

An example. Let $u = \cond. (0, (\lambda z.u)(z) )$, where we omitted the type superscript
of $z$. Then $u$ is safe-normal, because
all redexes in $u$ are of the form  $(\lambda z.u)(z)$ and in the right-hand-side of a $\cond$. 
However, the tree form of $u$ has the following branch:
$$
u, \ \ \ 
(\lambda z.u)(z), \ \ \ 
\lambda z.u, \ \ \ 
u, \ \ \ \ldots
$$
This branch is cyclic, infinite,
and it includes infinitely many $\beta$-redexes.

The reason for forbiding
reductions in the right-hand-side $\cond(f,g)$ is that through branches crossing the right-hand-side
of some $\cond$ we will-express fixed-point equations.
Therefore reductions on these branches can easily loop, and they are ``unsafe". 
For this reason, we first consider the minimum possible of reductions of the form:
$\cond(f,g)(0) \reduces_\cond f$ and
$\cond(f,g)(\Succ (t)) \reduces_\cond g[t/x]$: only  those on maximal $\cond$-expression.
We consider no reduction inside the second argument of $\cond$.
In a second moment, 
by adding a restriction of \emph{fairness} on reduction strategies,
we will be able to recover strong normalization for most ``unsafe" reductions.

We include one example of safe $\cond$-reductions of a term $v(n)$ to a normal form. 
Assume $n \in \Num$ is any numeral and $v = \cond(0, v)$. There are only finitely many reductions
from $v(n)$ instead, and they are all safe. $v(n)$ $\cond$-reduces to $v(n-1)$, 
then we loop: $v(n-1)$ $\cond$-reduces to $v(n-2)$ and so forth.
After $n$ $\cond$-reductions we get $v(0)$. With one last $\cond$-reduction we get $0$ and we stop. 
Thus, the term $v(n)$ strongly normalizes in $(n+1)$-steps.


\section{The trace of the cyclic $\lambda$-terms}
%19:34 27/03/2024
We introduce the set $\GTC$ of the set $\WTyped$ of well-typed terms of $\LAMBDA$ 
satisfying a condition call \emph{global trace condition} for all proofs that the term is well-typed.

In order to define the global trace condition, 
first we define a notion of trace for possibly infinite $\lambda$-terms, 
describing how an input of type $\N$ is used when computing the output.
The first step toward a trace is defining a connection between atoms in the
proof that $t$ is well-typed. We need first the notion of \emph{list of argument
 types} and of \emph{index of atomic types} for a term.

We sketch the notion of connection through an example.
Assume ${x_1}^{A_1}:A_1,{x_2}^{A_2}:A_2 \vdash t[x_1,x_2]:B_3 \rightarrow \N$.
Then the list of argument types of $t$
is $A_1, A_2, B_3$. $A_1,A_2$ are arguments with names $x_1, x_2$, and $B_3$ is an unnamed
argument. Remark that for an open term $ t[x_1,x_2]$ we list as ``argument types'' also the
types of the free variables. We motivate our terminology:
in a sense, $t$ is an abbreviation of the closed term $t' = \lambda  
{x_1}^{A_1},{x_2}^{A_2}.t: (  A_1,A_2,B_3 \rightarrow \N )$, and the argument types of $t'$ are
in fact $A_1, A_2, B_3$. 
The index of an argument type of $t$ is any $j \in \{1,2,3\}$ such that $A_j=\N$
or $B_j=\N$ respectively.

\begin{definition}[List of argument types of a term]
Assume that $\vec{A} = A_1, \ldots, A_n$, $\vec{B}=B_{n+1}, \ldots, B_{n+m}$, 
$\Gamma = \{\vec{x}:\vec{A}\}$,
and $\Gamma \vdash t: \vec{B} \rightarrow \N$.

\begin{enumerate}
\item
The \emph{list of argument types} of $t$ is $\vec{C} = \vec{A},\vec{B}$. 

\item
$A_1, \ldots, A_n$ are the \emph{named arguments}, with names $x_1, \ldots, x_n$.

\item
$B_{n+1}, \ldots, B_{n+m}$ are the \emph{unnamed arguments}.

\item
An \emph{index of an an argument type} 
of $t$ is any $j \in \{1, \ldots, n+m\}$ such that $C_j = \N$.

\end{enumerate}
\end{definition}

We now define the atom connection between arguments of type $\N$ of subterms of $t$
in a proof $\Pi: t:\Gamma \vdash A$ of  $\LAMBDA$. 
The definition of  atom connection for a syntax including the binder $\lambda$ 
is the main contribution of this paper. 
%Two arguments of type $\N$ are in
%connection if and only if they receive the same global input: local input are ignored.
%In many cases two corresponding argument types have the same index, but if we insert or remove
%free variables or arguments the index may change.
Before providing the general definition, we discuss the notion of connection through examples. 
We draw in the same color two arguments of type $\N$ which are in connection. 
\begin{Eg}\label{eg:0}\rm
An example of  atom connection for some instance of the weakening rule.
\[
\infer[(\weak)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}, x_3:\bfColor{oldgold}{\N}
					\prove t : \bfColor{orange}{\N} \rightarrow \N}
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N} 
					\prove t : \bfColor{orange}{\N} \rightarrow \N}
\]
\end{Eg}
Remark that the type $\N$ of the variable $x_3$ (colored in \bfColor{oldgold}{old gold}) , 
introduced by weakening, is in connection with no type in the rule $\weak$.

%20:13 15/04/2024
\begin{Eg}\label{eg:1}\rm
An example of  atom connection for the rule $\ap$.
We assume that $a$ is \emph{not} a variable.
\[
\infer[(\ap)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove f(a) : \bfColor{orange}{\N} \rightarrow \N}
    {
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove f : \bfColor{oldgold}{\N}, \bfColor{orange}{\N} \rightarrow \N}
      {\ \ \ \ \ \ }
      {   {x_1} : \bfColor{red}{\N}, x_2: \bfColor{blue}{\N}
					\prove a : \N}
	}
\]
\end{Eg}
Remark that the first unnamed argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
is in connection with no argument in the rule $\ap$.
The reason is that in the term $f(a)$,
the first argument of $f$ receives a value from the value $a$ which is local to the term $f(a)$,
does not receive a value from outside the term.
However, the first argument of $f$ can be in connection with some argument higher in the typing proof. 
%13:21 15/04/2024

\begin{Eg}\label{eg:2}\rm
An example of  atom connection for the rule $\cond$.
\[
\infer[(\cond)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove \cond(f,g) : \bfColor{oldgold}{\N} \rightarrow \N}
    {
      {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove f : \N}
           {\ \ \ \ \ \ }
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}, x  : \bfColor{oldgold}{\N} 
					\prove g : \N}
    }
\]
\end{Eg}
Remark that the first unnamed argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
is in connection the type of the free variable $x$ in the premise for $g$,
but it is in connection with no argument in the  in the premise for $f$.


\subsection{A formal definition of atom connection}
We define an injection $$\ins:\N,\N \rightarrow\N$$
by $\ins(p,x)=x+1$ if $x \ge p+1$, and $\ins(p,x)=x$ if $x\le p$.
The role of $\ins$ is inserting one fresh index $p+1$ for a new argument type.

\begin{definition}[Atom connection in a proof of  $\LAMBDA$]
Assume $\vec{A} = A_1, \ldots, A_n$, $\vec{B}=B_1, \ldots, B_m$, $\Gamma = \vec{x}:\vec{A}$,
and $\Gamma \vdash t:\vec{B} \rightarrow \N$.

For each atom index $k$ in $t$, for $t'=t$ or $t'$  immediate subterm of $t$ 
each atom index $k'$ in $t'$ we define the relation: ``$k',t'$ the successor of $k,t$". We require:
\begin{enumerate}
\item
if $t$ is obtained by a rule $\weak$ from $t'=t$, adding a variable in position $p+1$,   
then $k = \ins(p,k')$.
\item
if $t=f(a)$ and $a$ is not a variable and $t'=f$ 
then $k' = \ins(n,k)$. If $t'=a$ then $k'=k$ and $k' \le n$.
\item
if $t=\cond(f,g)$ and $t'=f$ 
then $k' = \ins(n,k)$. If $t'=g$ then $k'=k$.
\end{enumerate}
We require $k = k'$ in all other cases, 
which are: $\Succ $, $\lambda$, $\apvar$.
\end{definition}


Below we include some examples. 
We draw in the same color two arguments of type $\N$ which are in connection. 


\begin{Eg}\label{eg:3}\rm
Atom connection for $\apvar$.
We assume that $x$ is a variable.
\[
\infer[(\apvar)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}, x  : \bfColor{oldgold}{\N}
					\prove f(x) : \bfColor{orange}{\N} \rightarrow \N}
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove f : \bfColor{oldgold}{\N}, \bfColor{orange}{\N} \rightarrow \N}
\]
\end{Eg}
Remark that the first unnamed argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
in the premise is in connection with the last variable type in the conclusion of the rule.

\begin{Eg}\label{eg:4}\rm
Atom connection for  $\lambda$-rule.
We assume that $x$ is  a variable.
\[
\infer[(\ap)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove \lambda x.b : \bfColor{oldgold}{\N} \rightarrow \N}
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}, x  : \bfColor{oldgold}{\N}
					\prove b : \N}
\]
\end{Eg}
Remark that the first unnamed argument of $\lambda x.b$ (colored in \bfColor{oldgold}{old gold}) 
in the conclusion is in connection with the last variable type in the premise of the rule.
\\

Summing up, if 
we move up in a $\apvar$-rule, the type of one free variable corresponds to the type of one argument.
In a $\lambda$-rule it is the other way round. 

The connection on atoms in a proof $\Pi:\Gamma\vdash t:A$ defines a graph $\Graph(\Pi)$ 
whose nodes are all pairs $(k,u)$, with $u$ subterm of $t$ and $k$ index of some atomic argument of  $u$.
$\Graph(\Pi)$ is finite if $t$ is regular.
We define a trace as a (finite or infinite) path in the graph $\Graph(\Pi)$.

\begin{definition}[Trace for well-typed terms in $\LAMBDA$]
Assume $\Pi$ is any typing proof of $t \in \WTyped$.
\begin{enumerate}
\item
A path of $t$ is any finite or infinite list $\pi =(t_0, \ldots, t_n, \ldots)$ such that for all
$t_{i+1}$ in $\pi$ we have $t_{i+1}=t_i$ or $t_{i+1}=t_i$ immediate subterm of $t_i$.

\item
Assume $\pi =(t_0, \ldots, t_n, \ldots)$ is a path of $t$, finite or infinite. 
A finite or infinite \emph{trace} $\tau$ of $\pi$ in $\Pi$ is a list 
$\tau =( (k_m,t_m), \ldots, (k_n,t_n), \ldots)$ such that for all $i=m,\ldots, n,\ldots$:
\begin{enumerate}
\item
$k_i$ is the index of a type $\N$ of $t_i$
\item
if $i+1$ is an index of $\tau$ then $(k_{i+1},t_{i+1})$ is in connection with $(k_i, t_i)$ in $\Pi$.
\end{enumerate}

\end{enumerate}
\end{definition}

%20:50 15/04/2024
%10:35 24/04/2024

\section{The circular system $\CTlambda$}
We define a subset $\CTlambda$ of the set $\WTyped$ of well-typed term,
by adding the global trace condition and regularity. 
For the terms of $\CTlambda$ we will prove
strong normalization, church-rosser for terms of type $\N$, and the fact that every term of type
$\N$ is a numeral. 
As a consequence, terms $\CTlambda$ will be interpreted as total functionals. 

From the atom connection we define the global trace condition and terms $\CTlambda$.

We say that a tree is regular if it has finitely many subtrees. $t=\cond(0,t)$ is an infinite regular tree,
with subtrees: $t$, $0$.

\begin{definition}[Global trace condition and terms of $\CTlambda$]
Assume $\tau =( (k_m,t_m), \ldots, (k_n,t_n), \ldots)$ 
is a trace of a path $\pi = (t_1, \ldots, t_n, \ldots)$ of $t \in \WTyped$. Assume $i=m,\ldots, n$.
\begin{enumerate}
\item
$\tau$ is progressing in $i$ if $t_i=\cond(f,g)$ for some $f$, $g$,
and $k_i$ is the index of the first \emph{unnamed} argument the $\cond$-rule, 
otherwise $\tau$ is not progressing in $i$.

\item
$t$ satisfies the global trace condition if for all typing proofs $\Pi$,
of $t$, all infinite paths $\pi$ of $t$ in $\Pi$,
there is some infinitely progressing path $\tau$ in $\pi$ and $\Pi$.

\item
Terms of $\CTlambda$ are all well-typed terms which are regular trees (having finitely many subtrees), 
and satisfy the global trace condition.

\end{enumerate}
\end{definition}

The notion of global trace condition is defined through a universal quantification on proof 
$\Pi:\Gamma \vdash t:A$, and proofs $\Pi$ are possibly infinite objects.
We would expect that the global trace condition is not decidable. 
Surprisingly, it is decidable in polynomial space in $t$. The reason is that is some proof satisfies
the global trace condition then all proofs do, and for regular terms profos are finite graphs.

Besides, the global trace condition should be decidable quite fast
for realistic $\lambda$-terms.


\section{Examples of terms of $\CTlambda$}

\subsection{The sum map}
%\Daisuke{Add sum (start)}
A first example of term of  $\CTlambda$. 
In this example, the type superscript $\N$ of variables $x^\N, z^\N$ is omitted.
We provide a term $\Sum$ computing the sum on $\N$,
which is an infinite term defined by $\Sum = \lambda x.\cond(x,\lambda z.\Succ(\Sum(x)(z)))$.
This term is regular with subterms 
$$
\Sum, \  \  \ \cond(x,\lambda z.\Succ(\Sum(x)(z))), 
\  \  \ x, \  \  \ \lambda z.\Succ(\Sum(x)(z)),  \  \  \ \Sum(x)(z), \  \  \ \Sum(x)
$$
This term is well-typed by the following circular derivation with a back edge from the 
$\bfColor{oldgold}{\dagger}$ above to the $\bfColor{oldgold}{\dagger}$ below.
We colored in \bfColor{oldgold}{old gold} one sequence of atoms $\bfColor{oldgold}{\N}$ 
(one trace of the proof).
This is a cyclic infinitely progressing trace in the unique infinite path of the proof. 
We marked $\bfColor{oldgold}{ \spadesuit}$ the only progress point.
\[
\infer[\lambda]{
  \vdash \Sum:\N, \bfColor{oldgold}{\N} \rightarrow \N 
   \ \ \ (\bfColor{oldgold}{\dagger})
}{
  \infer[\cond]{
    x : \N \vdash 
    \cond(x,\lambda z.\Succ(\Sum(x)(z))): \bfColor{oldgold}{\N} \rightarrow \N
  }{
    \infer[\var]{
      x : \N \vdash x
    }{}
    &
    \infer[\Succ]{
      x:\N, z : \bfColor{oldgold}{\N} 
      \vdash \Succ(\Sum(x)(z)): \N  
        \ \ \ (\bfColor{oldgold}{ \spadesuit})
    }{
      \infer[\apvar]{
       x:\N, z : \bfColor{oldgold}{\N} 
       \vdash \Sum(x)(z): \N
      }{
         \infer[\apvar]{
       x:\N, z : \N
       \vdash \Sum(x): \bfColor{oldgold}{\N} \rightarrow \N
         }{
         \infer[\weak]{
         x:\N, z : \N
         \vdash \Sum: \N, \bfColor{oldgold}{\N} \rightarrow  \N
          }{
         \vdash \Sum: \N, \bfColor{oldgold}{\N} \rightarrow \N 
           \ \ \ (\bfColor{oldgold}{\dagger})
          }
        }
      }
    }
  }
}
\]

%
%\begin{tikzpicture}
%  %\draw [help lines] (-3,-1) grid (9,7);
%  \coordinate (a) at (0,0) node at (a) {A};
%  \coordinate (c) at (0,5) node at (c) {C};
%  \draw (0,0) -- (0:2cm);
%  \draw (0,0) -- (30:3cm);
%  \draw (0,5) -- +(0:2cm);
%\end{tikzpicture}

%\Daisuke{Add sum (end)}\\

%10:43 16/04/2024

\subsection{The Iterator}
A second example. We define a term $\Iter$ of  $\CTlambda$ computing the iteration of maps on $\N$.
$\Iter$ is a normal term of type $(\N \rightarrow \N), \N,\N \rightarrow \N$ such that
$\Iter(f,a,n)=f^n(a)$ for all numeral $n \in \Num$. 
We have to to solve the equations $\Iter(f,a,0) \sim a$ and $\Iter(f,a,\Succ (t)) \sim f(\Iter(f,a,t))$
where $f$, $a$ abbreviate $f^{\N\rightarrow\N}$ and $a^\N$.
We solve them with $\Iter = \lambda f, a.\iter$
where $\iter = \cond (a, \lambda x.f(\iter(x))):\N \rightarrow \N$ 
is in the context $\Gamma = (f:\N \rightarrow \N, a:\N)$.

The term is well-typed and regular by definition. We check the global trace condition. 
We follow the trace of the last unnamed argument $\N$ of $\Iter$. The trace moves
to $\lambda a.\iter$, then to $a:\N$ in the context of $\iter$.
Then the trace either moves to the name $a$ and there the path stops, or 
the trace progresses and moves to the context of $f(\iter(x))$, then to the context of $f$ or the context of $\iter(x)$. 
Either the path stops in $f$, or the path moves to $\iter(x)$ and then to $\iter$.
%??????????????? 10:30 24/03/24
Now we loop: if the path continues forever, then after infinitely many step the trace 
progresses infinitely many times, each time it moves to the right-hand side of a $\cond$-rule.
We sum up our discussion in the picture below. 
Again, we have a back edge from the 
$\bfColor{oldgold}{\dagger}$ above to the $\bfColor{oldgold}{\dagger}$ below
and we marked $\bfColor{oldgold}{ \spadesuit}$ the only progress point.
We abbreviate $\Gamma = (f:\N \rightarrow \N, a:\N)$.


\[
\infer[\lambda]{ %opening: \infer[\lambda]
  \vdash \Iter:(\N \rightarrow \N), \N, \bfColor{oldgold}{\N} \rightarrow \N
 }{
  \infer[\lambda]{ %opening: \infer[\lambda]
  f:\N \rightarrow \N
  \vdash \lambda a.\iter:\N, \bfColor{oldgold}{\N} \rightarrow \N
  }{
    \infer[\cond]{ %opening: \infer[\cond]
      \Gamma 
      \vdash \cond(a,\lambda x.f(\iter(x))): \bfColor{oldgold}{\N} \rightarrow \N 
        \ \ \ (\bfColor{oldgold}{ \spadesuit}, \bfColor{oldgold}{\dagger})
     }{ 
         \infer[\var]{
       \Gamma 
      \vdash a:\N}{}
     &
        {\ \ \ \ \ \ }
        {\infer[\lambda] %opening: \infer[\lambda]
         {
         \Gamma
          \vdash \lambda x.f(\iter(x)):\bfColor{oldgold}{\N} \rightarrow \N
         }{
         \infer[\ap]{ %opening: \infer[\ap]
           \Gamma, x:\bfColor{oldgold}{\N}
          \vdash f(\iter(x)):\N
           }{
          \infer[\var]{
       \Gamma, x:\N 
      \vdash f:\N}{}
           {\ \ \ \ \ \ \ \ \ \ \ \ }
           {\infer[\apvar] %opening: \infer[\apvar]
            {\Gamma, x:\bfColor{oldgold}{\N}
        \vdash \iter(x): \N \rightarrow \N 
             }{
          \Gamma, x:\N
        \vdash \iter: \bfColor{oldgold}{\N} \rightarrow \N
         \ \ \ (\bfColor{oldgold}{ \dagger})}}
        }%closing: \infer[\apvar]
      }%closing: \infer[\ap]
    }%closing: \infer[\lambda]
   }%closing: \infer[\cond]
 }%closing: \infer[\lambda]
}%closing: \infer[\lambda]
\]




\subsection{The Interval Map}
A third example. We simulate lists with two variables $\nil:\alpha$ and 
$\cons:\N,\alpha \rightarrow \alpha$. We recursively define a notation for lists by $[]=\nil$,
$a @ l=\cons(a,l)$ and $[a,\vec{a}] = a @ [\vec{a}]$. We add no elimination rules for lists, though,
only the variables $\nil$ and $\cons$. Elimination rules are not required in our example.

We will define a term $\Interval$ with one argument $f:\N \rightarrow \N$ and three argument
$a,x,y:\N$ (we skip type superscripts), such that 
$$
\Interval(f,a,n,m) \reduces [f^n(a), f^{n+1}(a), \ldots, f^{n+m}(a)]
$$ 
for all numeral $n,m \in \Num$. 
We have to to solve the recursive equations 
$$
\Interval(f,a,n,0)  \sim [f^n(a)]
\ \ \ \ \ \ 
\Interval(f,a,n,\Succ (m))  \sim f^n(a) @ \Interval(f,a,\Succ(n),m)
$$ 
Assume $\iter = \cond (a, \lambda x.f(\iter(x))):\N \rightarrow \N$ is defined 
as in the previous sub-section: in particular, $\iter(n) \sim f^n(a)$.
We solve the recursive equation for $\Interval$ with $\Interval = \lambda f,a.\interval$,
where 
$$
f:\N\rightarrow\N, a:\N \vdash \interval:\N,\N \rightarrow \alpha
$$
is defined by 
$$
\interval 
= 
\lambda x.\cond (\ [\iter(x)],  \  \lambda y.\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )
$$ 
The term is well-typed and regular by definition. We check the global trace condition.
Any infinite path either moves to $\iter$, for which we already checked the global trace condition,
or cyclically moves from $\interval$ to $\interval$.
We follow the trace of the last unnamed argument $\N$ of $\Interval$ inside this infinite
path.
The trace moves to the last unnamed argument $\N$ of  
$\interval:\N,\N \rightarrow \N$, then to the last unnamed argument of
$\cond (\ [\iter(x)],  \  \lambda y.\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )$.
In this step the trace progresses, and moves to 
the first unnamed argument of $\lambda y.\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )$,
then to $y:\N$ in the context of $\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )$.
After one $\apvar$ rule, the trace reaches the unique unnamed argument of 
$(\lambda x.\interval)(\Succ(x))$, then the last unnamed argument of $\interval$. 
From $\interval$ we loop. Each time the trace moves from $\interval$ to $\interval$
then the trace progresses once. We conclude the global trace condition.

%14:27 24/04/2024

We have infinitely many nested $\beta$-reduction $(\lambda x. \ldots)(\Succ (x))$.
We can remove all of them in a single step. Inside the $\beta$-redex number $k$ we obtain a sub-term
$\iter[\Succ (x)/x]\ldots[\Succ (x)/x]$ (substitution repeated $k$ times).
The result is $\iter[\Succ ^k(x)/x] $.
The nested substitution produce infinitely many pairwise different sub-terms 
$\iter(\Succ ^k(x))$ for all $k \in \N$.
We need infinitely many steps to normalize all $\iter(\Succ ^k(x))$ to $f^k(I)$, 
even if we allow to reduce all $\beta,\cond$-redexes at the same time.
Also the normal form is not regular: it contains all terms $f^k(\iter(x))$ for $k \in \N$, hence
infinitely many pairwise different terms. 
%These infinite sub-terms are of a particulary simple form, though. 
%They are obtained by the repeating $k$ times the assignment $z:=f(z)$, then applying $z:=I$ once
%to the result.

Summing up, 
$\Interval$ is some term of $\CTlambda$ which cannot be normalized in finite time, not even if we allow
infinite parallel reductions without any "safety" restriction. 
The normal form is produced \emph{only in the limit}
and it is \emph{not regular}. If we allow to reduce infinitely many nested $\beta$-redexes in one step, also
the intermediate steps of the infinite reduction of $\Interval$ are not regular.



\section{Subject reduction for terms of $\CTlambda$ of type $\N$}
%\Daisuke{SR start}
\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
\\
\emph{(Here we should fill this part)}
\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
%\Daisuke{SR end}

%15:12 16/04/2024
%15:46 24/04/2024

\section{Weak normalization for closed terms of $\CTlambda$ of type $\N$}
\label{section-weak-normalization}
%\Daisuke{WN start}
In this section we prove that every closed term of $\CTlambda$
 (that is, well-typed, regular and with the global trace condition) normalizes with finitely many "safe" steps
to some numeral $n \in \N$.
In the following, we explicitly write $t[x_1,\ldots,x_n]$,
when each free variable in $t$ is some $x_i$, 
and, under this notation, we also write $t[a_1,\ldots,a_n]$ instead of $t[a_1/x_1,\ldots,a_n/x_n]$. 
We recall that we denote with $\Nat$ the set of all numerals, namely the set of all terms of the form
$\Succ^n(0)$ for some $n\in \N$.

We define closed total terms as in Tait's normalization proof, and we define values.
Values are always closed total terms,
the only different between values and closed total terms 
is that if a value has type $\N$ then it is a numeral.

Here is the informal definition. We define values of type $\N$, which are numerals (hence closed term). 
We define total terms $t$ of type $\N$, which are
the closed terms of type $\N$ evaluating in at least one reduction path to a numeral, and
include values of type $\N$. 
Closed total terms and values of type $t:\alpha$ (with $\alpha$ type variable) coincide, 
both are all closed terms.
Closed total terms and values of type $t:A \rightarrow B$ coincide, 
both are the terms mapping values to total terms. 
An open term is total if all substitutions of free variables with values produce a closed \emph{total} term.

Below is the formal definition of values, closed total terms and total terms.

\begin{definition}[Values and total term]
  We define values and closed total terms on values by induction on types. 
  \begin{enumerate}
  \item
    A closed term $t:\N$ or is a \emph{value} if and only if $t \in \Nat$ ($t$ is some numeral).
  \item
    A closed term $t:\N$ is \emph{closed total}
    if and only if $t \safeReduces^* u$ for some $u\in \Nat$.
  \item
    Closed terms and values of type $t:\alpha$ (type variable) coincide, both are all closed terms.
   \item
    A closed term $t:A\rightarrow B$ is a \emph{value}
    if and only if $t(a)$ is closed total for any value $a:A$.
   \item
    Closed terms and values of type  $t:A\rightarrow B$ coincide.
  \item
    A term $t[\vec{x}]:C$ (i.e., whose free variables are in $\vec{x}:\vec{A}$), is
    \emph{total} if and only if $t[\vec{a}]$ is closed total for any values $\vec{a}$ of type $\vec{A}$.
  \end{enumerate}
\end{definition}

We can assign values to all arguments of a term and to any sub-term chain.

\begin{definition}[trace-compatible assignment]
 Assume $t \in \WTyped$ is a well-typed term of $\LAMBDA$ in the context 
 $\Gamma = \vec{x}:\vec{B}$.
 Assume $t[\vec{x}]:\vec{A}\rightarrow\N$ has argument types $\vec{B},\vec{A}$ in $\Gamma$.
Assume $\pi = (t_1, \ldots, t_n) \in \SubTerm(t)$ is any chain of immediate subterms of $t$.
 \begin{enumerate}
 \item
 A value assignment $\vec{v}$ for $t$ in $\Gamma$ is any vector 
$\vec{v}=\vec{u},\vec{a}:\vec{B}\vec{A}$ of closed values.
 \item
 A trace-compatible assignment $\vec{v} = (\vec{v_1}, \ldots, \vec{v_n})$ 
  for $\pi$ is any vector of value assigments, each $\vec{v_i}$ value assignment for $t_i$, 
  which satisfies the following condition. 
  For all $j$ argument of $t_i$ assigned to $\Succ^{a}(0)$, 
  all  $k$ argument of $t_{i+1}$ assigned to $\Succ^{b}(0)$, if $j$ corresponds to $k$ then:
 \begin{enumerate}
 \item
 if $j$ progresses to $k$ we have $a=b+1$
 \item
 if $j$ does not progress to $k$ we have $a=b$.
 \end{enumerate}
 
\end{enumerate}
\end{definition}

If an infinite path has a trace-compatible assignment, then all traces of the path progress only finitely many times.

\begin{proposition}[Trace assigment]
\label{prop:trace_assign}
If $t \in \WTyped$, $\pi \in \Tree(t)$ is an infinite path, $\rho$ is a value assignment to $\pi$.
\begin{enumerate}
\item
\label{prop:trace_assign1}
If an argument $j$ of some $t_i \in \pi$ has type $\N$ and value $\Succ^n(0)$, then a trace
from $j$ progresses at most $n$ times.
\item
\label{prop:trace_assign2}
$t \not \in \GTC$.
\end{enumerate}
\end{proposition}

\begin{proof}
\begin{enumerate}
\item
%\label{prop:trace_assign1}
By definition of trace-compatible assignment, whenever the trace progresses, 
the natural number $n$ decreases by $1$,
and whenever the trace does not progress, the the natural number $n$ remains the same.
Thus, a trace from $j$ progresses at most $n$ times, as we wished to show.
\item
%\label{prop:trace_assign2}
By point \ref{prop:trace_assign1} above, 
no trace from any argument in any term of the branch $\pi$ of $\Tree(t)$ progresses infinitely many times.
By definition of $\GTC$, we conclude that $t \not \in \GTC$. 
\end{enumerate}
\end{proof}

Closed total terms are closed by safe reductions and by application. 

\begin{lemma}\label{lem:total_value}
  \begin{enumerate}
  \item\label{lem:total_value1}
    Let $t:A$ be a closed term and $t \safeReduces u$.
    If $u$ is total, then so is $t$.
  \item\label{lem:total_value1bis}
    Let $f:A \rightarrow B$, $a:A$ be closed \emph{total} terms.
    Then so is $f(a)$.
  \item\label{lem:total_value2}
    Let $t[\vec{x}]:\vec{A}\rightarrow\N$ be a term,
    whose all free variables are $\vec{x}:\vec{B}$,
    and $\vec{u}:\vec{B}$ and $\vec{a}:\vec{A}$ be closed values.
    If all $t[\vec{u}]\vec{a}:\N$ are total, then $t[\vec{x}]$ is total. 
  \end{enumerate}
\end{lemma}
\begin{proof}
\begin{enumerate}

\item
  \emph{Point \ref{lem:total_value1}} is shown by induction on $A$. 
By the subject reduction property, $u$ has type $A$.
\begin{enumerate}
\item
  We first show the first \emph{base case}, namely when $A =\N$.
  By the assumption, $u$ is closed total.
  By definition of $u$ closed total, we have $t \safeReduces u \safeReduces^* n$ for some $n\in\Num$. 
  Hence $t:\N$ is total.
\item
  We first show the second \emph{base case}, namely when $A =\alpha$.
  Both $t$ and $u$ are closed terms of type $\alpha$, therefore are closed total terms.
\item
  We show the \emph{induction case}, namely when $A = (A_1\rightarrow A_2)$.
  Take arbitrary closed value $a:A_1$. Then we have $t(a) \safeReduces u(a)$ and 
  $u(a):A_2$ is total by the assumption that $u$ is total.
  Hence by the induction hypothesis $t(a)$ is total. 
  We obtain that $t:A_1\rightarrow A_2$ is total. 
\end{enumerate}

  \item
\emph{Point \ref{lem:total_value1bis}} is shown by case reasoning.
Assume that$f:A \rightarrow B$, $a:A$ are closed total terms, in order to prove
that $f(a)$  is closed total .

Assume $A$ is a variable type or an arrow type. 
Then $a:A$ is a value because values and closed total terms of type $A$
coincide, therefore $f(a):A$ is closed total by definition of closed total.

Assume $A=\N$. Then $a \safeReduces n$ for some $n \in \Num$ by definition of closed total.
$f(n)$ is closed total by definition of closed total. $f(a)$ is closed total by $f(a) \safeReduces f(n)$
and point \ref{lem:total_value1bis} above.

\item  
  \emph{Point \ref{lem:total_value2}} is shown by induction on $|\vec{A}|$.
\begin{enumerate}
\item
  The \emph{base case} $|\vec{A}| = 0$ is immediately shown by the definition.
\item
  We show the \emph{induction case}. Let $\vec{A} = A_0\vec{A'}$.
  Take arbitrary values $\vec{u}:\vec{B}$, $\vec{a'}:\vec{A'}$, and $a_0:A_0$. 
  By the assumption, we have $t[\vec{u}]a_0\vec{a'}:\N$ is closed total for all values $\vec{a'}$. 
  Then $t[\vec{u}]a_0:\vec{A'}\rightarrow\N$ is total 
  by the induction hypothesis on $\vec{A'}\rightarrow \N$.
  By definition $t[\vec{u}]:\vec{A}\rightarrow\N$ is closed total,
  and so by definition $t[\vec{x}]$ is total, as we expected.
\end{enumerate}

\end{enumerate}
\end{proof}

%10:28 19/04/2024

Let $\Pi$ be a proof of $\Gamma\vdash t:A$ and $e$ be a node of $\Pi$, that is, a chain  
$(t_1, \ldots, t_n) \in \Tree(t)$ of immediate
subterms of $t$ with $t_1 = t$.
We write $\Pi(e)$ for $\Gamma_n\vdash t_n:A_n$ with $\Gamma_n$ inherited contex of 
$t_n$ and $A_n$ the type assigned by $\Pi$ to $t_n$.

\begin{theorem}
  Assume $\Pi:\Gamma\vdash t:A$.
  If $t$ is \emph{not} total, then $t \not \in \GTC$, i.e.:
  there is some infinite path in $\Pi$ with no infinite progressing trace. 
\end{theorem}

%19:01 16/04/2024

\begin{proof}
  Assume that $t$ is not total
  and $t: \vec{x}:\vec{D}\vdash\vec{A}\rightarrow\N$ 
  has a proof $\Pi$ in order to show that $t \not \in \GTC$.
  By Proposition \ref{prop:trace_assign}.\ref{prop:trace_assign2} it is enough to prove that
  $\Pi$ has some infinite path $\pi$ and some trace-compatible assignment $\rho$ for $\pi$.
  By \ref{lem:total_value2} of Lemma~\ref{lem:total_value},
  there exist closed values $\vec{a}:\vec{A}$ and $\vec{d}:\vec{D}$ such that
  $t[\vec{d}]\vec{a}$ is not total. 
  By induction on $i$, we construct a term $e_i$ for each natural number $i$,
  and a value assignment $\vec{v_i} = (\vec{d_i},\vec{a_i})$ for $e_i$, such that 
  such that $\pi=(e_1, \ldots, e_n)$ is a chain of immediate subterms from $e_1  = t$
  and $(\vec{v_1},\ldots,\vec{v_n})$ is a trace-compatible assignment for $\pi$.
  We assume that:
  \begin{itemize}
  \item[(i)]
%15:38 19/04/2024
    $e_i$ is a node of $\Pi$, whose last term is 
    $t_i: \vec{x_i}:\vec{D_i}\vdash\vec{A_i}\rightarrow\N$ is
    at the node $e_i$ in $\Pi$, and $e_{i+1}$ is a child node of $e_i$ in $\Pi$; 
  \item[(ii)]
    $t_i$ is not total;
  \item[(iii)]
    $\vec{d_i}:\vec{D_i}$ and $\vec{a_i}:\vec{A_i}$ are closed values
    such that $t_i[\vec{d_i}]\vec{a_i}$ is not total;
  \item[(iv)]
    there is a trace-compatible assignment from
    ($\vec{d_i};\vec{a_i}$) to ($\vec{d_{i+1}};\vec{a_{i+1}}$), for any $i\ge 0$, in $\Pi$.
    Moreover, if $i$ is a progress point, namely $t_i$ is of the form $\cond(f,g)$ and $t_{i+1}$ is $g$,
    then $\vec{a_i} = \Succ(m')\vec{a'}$, $\vec{d_{i+1}} = \vec{d_i}m'$, and
    a trace passes from $\Succ(m')$ to $m'$. 
    %\Daisuke{mynote:write this more clearly}
  \end{itemize}
  
  We first define $(e_1,\vec{d_1},\vec{a_1})$ for the root node $t$ of $\Pi$.
  We choose $e_1 = t$ and $(\vec{d},\vec{a})$ values such that $t[\vec{d}](\vec{a})$ is not total.
  Points (i), (ii), (iii), (iv) are immediate.

  Next, assume that $(e_i,\vec{d_i},\vec{a_i})$ is already constructed.
  Then we define $(e_{i+1},\vec{d_{i+1}},\vec{a_{i+1}})$ by the case analysis on
  the last rule for the node $e_{i+1}$ in $\Pi$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPARENTLY THE CASE $\struct(f)$ CAN BE SIMPLIFIED TO WEAKENING-Stefano
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
\item
  The case of $\weak$, namely
  $\Pi(e_i) = t[y_{f(1)}/x_1,\ldots,y_{f(n)}/x_n]:\Delta\vdash \vec{A_i}\rightarrow\N$
  is obtained from $\Gamma\vdash t:A$, where
  $\Gamma = x_1:C_1,\ldots,x_n:C_n$, $\Delta = y_1:B_1,\ldots,y_m:B_m$, 
  $f:\{1,\ldots,n\}\to\{1,\ldots,m\}$ is an injection, 
  and $x_i^{C_i}=y_{f(i)}^{B_{f(i)}}$ for all $1\le i\le n$.
  By the induction hypothesis and $(b)$, the conclusion
  $t[y_{f(1)}/x_1,\ldots,y_{f(n)}/x_n][d_{i,f(1)}/y_{f(1)},\ldots,d_{i,f(n)}/y_{f(n)}]\vec{a_i}:\N$ 
  of $\weak$ is not total, where $\vec{d_i} = d_{i,1}\ldots d_{i,m}$.
  Then define $e_{i+1}$ as the unique parent node of $e_i$, and we
  also define $\vec{d_{i+1}}$ and $\vec{a_{i+1}}$ by $d_{i,f(1)}\ldots d_{i,f(n)}$
  and $\vec{a_i}$, respectively. 
  We obtain (i), (ii), and (iii) for $i+1$, as expected.
  We also have (iv) since the connection, determined by $f$, from
  $(d_{i,1}\ldots d_{i,m};\vec{a_i})$ to 
  $(\vec{d_{i+1}};\vec{a_{i+1}}) = (d_{i,f(1)},\ldots d_{i,f(n)};\vec{a_i})$
  is trace compatible. 

\item
  The case of $\var$-rule, namely $\Pi(e_i) = \Gamma\vdash x_j:C_j$, 
cannot be, because $t_i = [x_j/d_j] = d_j$ is closed total by assumption on $\vec{d}$.

\item
  The case of $0$-rule, namely $\Pi(e_i) = \Gamma\vdash 0:\N$, cannot be, because $t_i = 0$ is total
because it is a numeral.

\item  
  The case of $\Succ$-rule, namely $\Pi(e_i) = \Gamma\vdash \Succ(t_{i+1}): \N$ is obtained from
  $\Gamma\vdash t_{i+1}: \N$. $\vec{a_i}$ is empty, and
  by the induction hypothesis $\Succ(t_{i+1}[\vec{d_i}]):\N$ is not closed total.
  Then, by the definition of closed total, $t_{i+1}[\vec{d_i}]$ is not closed total. 
  Define $e_{i+1}$ as the unique parent node of $e_i$, and
  also define $\vec{d_{i+1}}$ and $\vec{a_{i+1}}$ by $d_i$ and the empty list, respectively. 
  We obtain (i), (ii), (iii), and (iv) for $i+1$, as expected.

\item
  The case of $\ap$-rule, namely 
  $\Pi(e_i) = \Gamma\vdash t[\vec{x}](u[\vec{x}]): \vec{A}\rightarrow\N$ is obtained from
  $\Gamma\vdash t[\vec{x}]: B \rightarrow \vec{A}\rightarrow\N$ 
  and $\Gamma\vdash u[\vec{x}]: B$.
  By the induction hypothesis, $t[\vec{d_i}](u[\vec{d_i}])\vec{a_i}:\N$ is not total.
  We argue by case on the statement: \emph{$u[\vec{d_i}]:B$ is closed total}.

\begin{enumerate}
\item
  We first consider the subcase that \emph{$u[\vec{d_i}]:B$ is closed total}.
  We define $a':B$ by $a' = n\in\Num$ such that $u[\vec{d_i}] \safeReduces^* n$ if $B=\N$,
  by $a' = u[\vec{d_i}]$ otherwise. By lemma \ref{}.\ref{}, $a'$ is a value.
  Then define $e_{i+1}=t[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = a',\vec{a_i}$. 
  Using Lemma~\ref{lem:total_value}, we obtain (i), (ii), (iii) for $i+1$, as expected. 
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};a',\vec{a_i})$ is
  trace-compatible: all connected arguments of type $\N$ of $e_{i}$ and $e_{i+1}$ are the same,
  because the only fresh argument of $e_{i+1}$ is $a'$ and no argument of $e_i$ is connected to it.
\item
  Next we consider the subcase that \emph{$u[\vec{d_i}]:B$ is not closed total}.
  By lemma \ref{}.\ref{}
  there is a sequence of values $\vec{a'}$ such that $u[\vec{d_i}]\vec{a'}:\N$ is not total.
  Define $e_{i+1}=u[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};\vec{a'})$ is
  trace compatible: all connected arguments of type $\N$ of $e_{i}$ and $e_{i+1}$ are 
  in $\vec{d_i}$ and therefore are the same.
 \end{enumerate}

\item
  The case of $\eta$-rule, namely 
  $\Pi(e_i) = f[\vec{x}](x): \Gamma,x^\N\vdash \vec{A}\rightarrow\N$ is obtained from
  $f[\vec{x}]:\Gamma\vdash N\rightarrow \vec{A} \rightarrow \N$, where
  $(x^\N:\N)\not\in\Gamma$.
  By the induction hypothesis, $f[\vec{d'}]d\vec{a_i}:\N$ is not total,
  where $\vec{d_i} = \vec{d'},d$ and $d$ is the value of the argument type of $x^\N$.
  Define $e_{i+1}$ as the unique parent node of $e_i$, and
  also define $\vec{d_{i+1}}$ by $\vec{d'}$ and define $\vec{a_{i+1}}$ by $d,\vec{a_i}$. 
  We obtain (i), (ii), and (iii) for $i+1$, as expected.
  We also have (iv) since the connection from
  $(\vec{d_i};\vec{a_i}) = (\vec{d'},d;\vec{a_i})$ to
  $(d_{i+1};\vec{a_{i+1}}) = (\vec{d'};d\vec{a_i})$
  is trace compatible: all connected argument in $\vec{d_{i}},\vec{a_{i}}$ and 
  $\vec{d_{i+1}},\vec{a_{i+1}}$ are the same. The only difference between the two assignments
  is that the value $d$ of the last argument type $\N$ is moved to the value $d$ 
  of the first unnamed argument of $f$. 

\item
  The case of $\lambda$-rule, namely
  $\Pi(e_i) = \lambda x^A.(t_{i+1}[\vec{x},x]):
    \Gamma\vdash A, \vec{A} \rightarrow \N$ is obtained from
  $t_{i+1}[\vec{x},x^A]:\Gamma,x^A\vdash \vec{A}\rightarrow\N$.
  By the induction hypothesis, $(\lambda x.(t_{i+1}[\vec{d_i},x]))a\vec{a'}:\N$ is not total,
  where $\vec{a_i} = a\vec{a'}$.
  Then, by Lemma~\ref{lem:total_value}, $t_{i+1}[\vec{d_i},a]\vec{a'}$ is not total. 
  Define $e_{i+1}$ as the unique parent node of $e_i$, and
  also define $\vec{d_{i+1}} = \vec{d_i},a$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i}) = (\vec{d_i};a\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i}a;
    \vec{a'})$ is trace-compatible: all connected argument in $\vec{d_{i}},\vec{a_{i}}$ and 
  $\vec{d_{i+1}},\vec{a_{i+1}}$ are the same. The only difference between the two assignments
  is that the value $d$ of the first unnamed argument of $t_i$ is moved to the value $d$
  of the last argument type $\N$.
  This is the opposite of the movement we have in the $\apvar$.

\item  
  The case of $\cond$-rule, namely
  $\Pi(e_i) = \cond(f[\vec{x}],g[\vec{x},x]):
    \Gamma\vdash C\rightarrow\vec{A}\rightarrow\N$
  is obtained from 
  $f[\vec{x}]:\Gamma\vdash \vec{A}\rightarrow\N$
  and
  $g[\vec{x},x]:\Gamma,x^\N\vdash \vec{A}\rightarrow\N$. 
  By the induction hypothesis, $\cond(f[\vec{d_i}],g[\vec{d_i},x])m\vec{a'}:\N$ is not total,
  where $\vec{a_i} = m\vec{a'}$ and $m \in \Nat$. We argue by cases on $m$.
\begin{enumerate}
\item
  We first consider the \emph{subcase $m=0$}.
  Define $e_{i+1}$ by the parent node whose term is $f[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected. 
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})
 =(\vec{d_i};0\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};\vec{a'})$
  is trace compatible: each argument of $e_i$ is connected to some equal argument of $e_{i+1}$,
  the first argument of $e_i$ disappears but it is connected to no argument in $f$.
\item
  Next we consider the \emph{subcase $m=\Succ(m')$}. 
  Define $e_{i+1}$ by the parent node whose term is $g[\vec{x},x]$,
  and define $\vec{d_{i+1}} = \vec{d_i},m'$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})
  =(\vec{d_i};\Succ(m'),\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i},m';\vec{a'})$
  is trace compatible: each argument of $e_i$ is connected to some equal argument of $e_{i+1}$,
  but for the argument $m$ of $e_i$ which is connected to $m'$ in the last argument type $\N$.
  This is fine because in the second premise of a $\cond$ 
  the trace progress. This requires that \emph{the numeral $m$ decreases by $1$}, as indeed it is the case.
\end{enumerate}

\end{enumerate}

  Hence, by the above construction, we have an infinite path $\pi = (e_1,e_2,\ldots)$ in $\Pi$
 and a trace-compatible assignment, as we wished to show.

%  Since $\Pi$ satisfies the global trace condition, $\vec{e}$ contains a progressing trace
%  $(k_{m},k_{m+1},\ldots)$, where, for each $m\le i$, $k_i$ is an atom index of $t_i$, 
%  and $k_{i+1},t_{i+1}$ is the successor of $k_i,t_i$. 
%  Let $n_i$ be an numeral in $\vec{d_i},\vec{a_i}$ at index $k_i$ for each $m\le i$.
%  Then the sequence $(n_m,n_{m+1},\ldots$ decreases at each progressing point.
%  This means that it decreases infinitely many times
%  since $(k_{m},k_{m+1},\ldots)$ has infinitely many progressing point.
%  Finally we have a contradiction. 
  
\end{proof}

From this theorem we derive the weak normalization result: 
every closed term of type $\N$ reduces to some numeral for at least
one reduction path. 

\begin{corollary}
Assume  $t: \Gamma\vdash A$,
\begin {enumerate}
\item
 $t \in \GTC$ implies that $t$ is total.
\item
  For any closed $t:\N$, there is numeral $n\in\Num$ such that $t\safeReduces^* n$. 
\end{enumerate}
\end{corollary}



%\Daisuke{WN end}

\section{Uniqueness of normal form for closed terms of $\CTlambda$ of type $\N$}
\label{section-uniqueness-normal-form}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
%\input{section-uniqueness-normal-form}


\section{Infinite reductions}
\label{section-infinite-reductions}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
%\input{section-infinite-reductions}



\section{Normalization and Fairness}
\label{section-normalization-fairness}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
%\input{section-normalization-fairness}


\section{Equivalence between cyclic and non-cyclic system $T$} 
\label{section-equivalence-cyclic-non-cyclic-T}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
%\input{section-equivalence-cyclic-non-cyclic-T}

%
%\section{appendix}
%
%\begin{verbatim}
%
%To: kmr@is.sci.toho-u.ac.jp (Daisuke Kimura)
%Re: proof of Weak Normalization to an integer for CT-lambda
%Fri, 22 Mar 2024 08:25:57 +0100 
%
%    By the way, I re-checked the weak curry-howard proof, now i think that the proof 
%does not require the property p-->q, a-->b ==> p[a/x]-->q[b/x] and can be completed 
%with the notion of safe reduction.
%but in fact it would be more interesting to prove full church-rosser for Circular T-lambda, 
%as anupam does for his circular T.
%
%    About strong normalization, we can prove it for "safe" reductions, those inside no cond. 
%More in general, we know that we can have infinite reduction sequences, because we can 
%have infinitely many redexes. However, for any infinite reduction sequence sigma, I conjecture 
%we can prove a kind of stabilization of the term. After some reduction step, the term only 
%changes inside some cond nested k times. 
%
%    Namely, I conjecture that
%
%"for any cyclic lambda term t, any infinite reduction sequence (sigma(n)|n in N) with sigma(0)=t, 
%any k in N, there is a n0 in N such that for all n>=n0, the terms sigma(n) and sigma(n0)  
%coincide on all branches with at most k times cond."
%
%    Best, Stefano
%
%\end{verbatim}






\end{document}
