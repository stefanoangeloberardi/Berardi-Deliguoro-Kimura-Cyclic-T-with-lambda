% lmcs, 2018.5.2, 2019.9.9, 2020.2.10



\newif\ifdraft \draftfalse
\drafttrue % put % for lipics


\long\def\Stefano#1{{{\color{red}{SB: #1}}}}
\long\def\Makoto#1{{{\color{blue}{MT: #1}}}}
\long\def\Daisuke#1{{{\color{green}{DK: #1}}}}

\ifdraft

\documentclass{article}
\usepackage{mystyle}
\A4page
%\usepackage{tikzpicture}
\usepackage{graphicx}

\else

\documentclass{lmcs}
\usepackage{hyperref}
%\usepackage{amsmath}heoremstyle{plain}\newtheorem{satz}[thm]{Satz} %\crefname{satz}{Satz}{\Succ    atze}
\usepackage{graphicx}

\fi

\usepackage{mymath,proof,latexsym}
\usepackage{xcolor}
\usepackage[pdftex,outline]{contour}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% AGGIUNGO TEOREMA LEMMA PROPOSIZIONE COROLLARIO PROVA % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


\begin{document}
\sloppy 
\hbadness=10000
\vbadness=10000

\input{macro}
\input{title}



\section{Introduction}
We will introduce $\LAMBDA$, a set of infinite $\lambda$-terms with a circular syntax.
The types of $\LAMBDA$ are: the atomic type $\N$, 
possibly type variables $\alpha, \beta, \ldots$, and all types $A \rightarrow B$ for any types $A$, $B$. 
Type variables are only used to provide examples and they play a minor role in our paper.

The terms of $\LAMBDA$  are all possibly infinite trees representing expressions defined with 
$0$,$\Succ $,$\ap$ (application), 
variables $x^T$ (with a type superscript $T$),  $\lambda$ (the binder for defining maps), 
and $\cond$, the arithmetic conditional (i.e., the test on zero). 
If we have no type variables, then the trees in $\LAMBDA$ represent partial functionals on $\N$, 
provided we add reduction rules transforming closed terms of type $\N$ in notations for natural numbers.

%19:42 19/04/2024

In this paper will consider two sets of terms: 
\begin{enumerate}
\item
the set $\CTlambda$ of well-typed terms in
a circular syntax, which are equivalent to the set of terms in G\"{o}del system $\systemT$.  
\item
The set of terms $\GTC$, satisfying a condition called global trace condition, which are possibly non-recursive
terms used to provide semantics for  $\CTlambda$
\end{enumerate}
We introduce more sets of terms required as intermediate steps in the definition of $\GTC$ and $\CTlambda$.

\begin{enumerate}
\item
 $\WTyped \subseteq \LAMBDA$, the set of well-typed terms, is the
of terms having a unique type
\item
$\Reg$ is the set of terms of $\LAMBDA$ which are regular trees (i.e., having finitely
many subtrees). They are possibly infinite terms which are finitely presented 
by a finite graph possibly having cycles.
\item 
$\GTC \subseteq \WTyped$ will be defined as the set of well-typed circular 
$\lambda$-terms satisfying the global trace condition and regular. 
Terms of $\GTC$ denote total functionals. 
\end{enumerate}

We will prove that $\CTlambda$ is a decidable subset of $\Reg$.
$\CTlambda$ is a new circular version of G\"{o}del system $\systemT$. 
Differently from all previous circular versions of $\systemT$, our system $\CTlambda$
uses binders instead of combinators. 
The circular syntax has the advange of writing much shorter terms while preserving decidability
of termination.
Besides, by introducing a circular syntax with binders, we hope to provide 
a circular syntax more familiar to researchers working in the field of Type Theory.
\\

We will prove the expected results for the circular syntax $\CTlambda$:
strong normalization for reductions not in the right-hand side of any $\cond$ and Church-Rosser. 
We will prove normalization in the limit if we use reductions which are ``fair'':
fair reductions can reduce \emph{inside} the right-hand side of some $\cond$, but they never forget entirely 
the task of reducing \emph{outside} all such subterms.

Eventually, we will prove that the closed terms $\CTlambda$ (those without free variables)
represent exactly the total computable functionals definable in G\"{o}del system $\systemT$.


%14:57 17/04/2024
%21:08 19/04/2024


\section{The set of infinite $\lambda$-terms}
We define the set $\LAMBDA$ of infinite circular terms, the subset $\WTyped$
of well-typed terms and a reduction relation for them. Infinite terms are labeled binary trees, therefore we
have to define binary trees first, and before them lists on $\{1,2\}$ and related notions.

\begin{definition}[Lists on $\{1,2\}$]
\begin{enumerate}
\item
We denote with $\List(\{1,2\})$ the set of all lists of elements of $\{1,2\}$: $(),(1),(1),(1,1),(1,2),\ldots$. 
We call the elements of $\List(\{1,2\})$ just lists for short.
\item
If $i_1, \ldots, i_n \in \{1,2\}$, we write $(i_1, \ldots, i_n)$
for the list with elements $i_1, \ldots, i_n$. 
\item
We write $\nil$ for the empty list, or $()$. 
\item
If $l=(i_1, \ldots, i_n)$, $m=(j_1, \ldots, j_m)$ and $l, m \in \List(\{1,2\})$ we define
$l \conc m = (i_1, \ldots, i_n,(j_1, \ldots, j_m)\in \List(\{1,2\})$. 
%If $I \subseteq \List(\{1,2\})$
%we write $l \conc I = \{l \conc m | m \in I\}$. 
\item
The prefix order $\le$ on lists
is defined by $l \le m$ if and only if $m = l \conc m'$ for some $m' \in  \List(\{1,2\})$.
\end{enumerate}
\end{definition}

\begin{definition}[Binary trees]
\begin{enumerate}
\item 
A binary tree, just a tree for short, is any set $T\subseteq \List(\{1,2\})$ 
of lists including the empty list and closed by prefix: $\nil \in T$ and for all $l, m \in \List(\{1,2\})$
if $m \in T$ and $l \le m$ then $l \in T$. 
\item
$\nil$ is called the root of $T$, any $l \in T$ is called a node of
$T$ and if $l \in T$, then any $l \conc (i) \in T$ is called a child of $l$ in $T$.
\item
A node $l$ of $T$ is a leaf of $T$ if $l$ is an maximal element of $T$ w.r.t. the prefix order (i.e.,
if $l$ has no children). 
\item
If $T$ is a tree and $l \in T$ we define $T \restr l = \{m \in \List(\{1,2\}) | l \conc m \in T\}$.
$T \restr l$ is a tree and we say that $T \restr l$ is a subtree of $T$ in the node $l$,
and for each $m \in T \restr l$ we say that $l \conc m$ is the corresponding node in $T$.
\item
If $l=(i)$ we say that $T_l$ is an immediate subterm of $T$.
\item
A binary tree labeled on a set $L$ is any pair $\setT = (T, \phi)$ with 
$\phi:T \rightarrow L$. We call $\universe{\setT}=T$ the set of nodes of $\setT$
and $\Label(\setT,l) = \phi(l)$ the label of $l$ in $\setT$.
\item
We define $\setT \restr l = (T \restr l, \phi_l)$ and $\phi_l(m) = l \conc m$. 
We call any $\setT \restr l$ a labeled subtree of $\setT$
in the node $l$, an immediate sub-tree if $l=(i)$. 
\end{enumerate}
\end{definition}

Remark that the labeling of a node $m \in \universe{\setT \restr l}$ 
is the same label of the corresponding node $l \conc m$ of $\universe{\setT}$.
 
Let $n = 0, 1, 2$. Assume $\setT_1, \ldots,\setT_n$ are trees labeled on $L$ and $l \in L$.
Then we define $$\setT = l \setT_1 \ldots \setT_n$$ as the unique tree labeled on $L$
with the root labeled $l$, i.e.: $\Label(\setT,\nil)=l$, and with:
$\setT \restr (i) = \setT_i$ for all $1 \le i \le n$.

Now we define the types of $\LAMBDA$, then the terms of $\LAMBDA$.

\begin{definition}[Types of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
The types of $\LAMBDA$ are: the type $\N$ of natural numbers, an infinite list 
$\alpha,\beta,\ldots$ of type variables, and with $A,B$ also  $A \rightarrow B$.
We call them simple types, \emph{types} for short. 

\item 
$\Type$ is the set of simples types.

\item
We suppose be given a set $\var$ of all pairs $x^T$ of a variable name $x$ and a type $T \in \Type$.
\end{enumerate}
\end{definition}

Terms of $\LAMBDA$ are labeled binary trees.


\begin{definition}[Terms of $\LAMBDA$]
The terms of $\LAMBDA$ 
are all binary trees $t$ with set of labels $L=\{x^T, \lambda x^T., \ap, 0, \Succ, \cond\}$
such that:
\begin{enumerate}
\item 
a node $l$ labeled $x^T$ or $0$ is a leaf of $t$ (no children). 
\item
a node $l$ labeled $\lambda x^T.$ or $\Succ$ has a unique child $l \conc (1)$. 
\item
a node labeled $\ap$, $\cond$ has two children $l \conc (1)$, $l \conc (2)$.
\end{enumerate}
We say that $t$ is a sub-term of $u$ if $t$ is a labeled sub-term of $u$,
an immediate subterm if it is an immediate subtree.
\end{definition}
 
Assume  $l \in L = \{x^T, \lambda x^T., \ap, 0, \Succ, \cond\}$.
We  use the operation $l \setT_1 \ldots \setT_n$ on labeled trees to define new terms in $\LAMBDA$.
If $t, u \in \LAMBDA$ then $x^T, 0, \lambda x^T.t,\ap(t,u),\Succ(t),\cond(t,u) \in \LAMBDA$ 
are terms with the root labeled $l$, and with immediate subterms among $t$, $u$. 
Conversely, each $v \in \LAMBDA$ is in one of the forms:
$x^T, 0, \lambda x^T.t$, $\ap(t,u)$, $\Succ(t)$, $\cond(t,u)$ for some $t, u \in \LAMBDA$.

Now we define regular terms.

%11:55 22/04/2024

\begin{definition}[Regular terms of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
We write $\SubTerm(t)$ for the (finite or infinite) set of subterms of $t$. 
Subterms are coded by the nodes of $t$. 

\item
$\Reg$ is the set of terms $t \in \LAMBDA$ such that $\SubTerm(t)$ is finite.
We call the terms of $\Reg$ the \emph{regular terms}.

%\item
%We write $\Tree(t)$ for the tree of all chains
%$(t_1, \ldots, t_n)$ with $t_1=t$ and weakly increasing by $\sqsubset_1$: 
% for all $(i+1) \le n$ we have $t_{i+1}=t_i$ or $t_{i+1} \sqsubset_1 t_i$.

\item
As usual, we abbreviate $\ap(t,u)$ with $t(u)$.

\item
When $t = \Succ ^n(0)$ for some natural number $n \in \Nat$
we say that $t$ is a numeral. We write $\Num$ for the set of numeral.

\item
A variable $x^T$ is free in $t$ if there is some $l \in t$ labeled $x^T$ in $T$, 
and no $m \le l$ labeled $\lambda x^T.$ in $t$. $\FV(t)$ is the set of free variables of $t$.
\end{enumerate}
 
\end{definition}

%We use two different names for the operation $\ap(t,u)$: 
%we call it $\ap$ when $u$ is not a variable and $\apvar$ when $u$ is a variable. 

$\Num$ is the representation inside $\LAMBDA$ of the set $\Nat$ of natural numbers.
All numerals are finite trees of $\Lambda$. 
All finite well-typed typed $\lambda$-terms 
we can define with the rules above are finite terms of $\LAMBDA$.
Regular terms can be represented by the subterm relation restricted to $\SubTerm(t)$:
this relation defines a graph with possibly cicles. 

Even if $\SubTerm(t)$ is finite, $t$ can be an infinite tree. 
An example of regular term which is an infinite tree: the term $t = \cond(0,t) \in \LAMBDA$. 
The set $\SubTerm(t)=\{t,0\}$ of subterms  of $t$ is finite, therefore $t$ is a regular term.
However, $t$ is an infinite tree (it includes itself as a subtree). 
The immediate sub-term chains of $t$ are all $(t,t,t,\ldots,t)$ and $(t,t,t,\ldots,0)$.
There is a unique infinite sub-term chain, which is $(t,t,t,\ldots)$. 

In order to define the type of an infinite term, we first 
define contexts and sequences for any term of $\LAMBDA$.
A context is a list of type assignments to variables: our variables already have a type superscript,
so a type assignment $x^T:T$ is redundant for our variables (not for our terms).
Yet, we add an assignment relation $x^T:T$ for uniformity with the notation $x:T$ 
in use in Type Theory.

%13:32 22/04/2024
%11:17 29/04/2024

\begin{definition}[Contexts of $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
A  context of $\LAMBDA$ is any finite list $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ 
of pairwise distinct variables, each assigned to its type superscript $A_1, \ldots, A_n \in \Type$. 

\item
We denote the empty context with $\nil$. We write $\Ctxt$ for the set of all contexts.

\item
A sequent is the pair of a context $\Gamma$ and a type $A$, which we write as $\Gamma \vdash A$.
We write $\Seq = \Ctxt \times \Type$ for the set of all sequents.

\item 
A typing judgement is the list of a context  $\Gamma$, a term $t$ and a type $A$, 
which we write as $\Gamma \vdash t:A$.
We write $\Stat = \Ctxt \times \LAMBDA \times \Type$ for the set of all typing judgements.

\item
We write $\FV(\Gamma) = \{ {x_1}^{A_1}, \ldots, {x_n}^{A_n} \}$.
We say that $\Gamma$ is a context for $t \in \LAMBDA$ and we write $\Gamma \vdash t$ 
if $\FV(t) \subseteq \FV(\Gamma)$.

\item
If $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ ,
$\Gamma' = (x'_1:A'_1, \ldots, x'_n:A'_{n'})$ are context of $\LAMBDA$, then we
write 
\begin{enumerate}
\item
$\Gamma \ \subseteqsim \ \Gamma'$ \ if for all $(x^A:A)$:  \ 
$(x^A:A) \in \Gamma  \ \Rightarrow  \  (x^A:A)\in\Gamma'$
\item
$\Gamma \sim \Gamma'$  \  if for all $(x^A:A)$:  \ 
$(x^A:A) \in \Gamma  \ \Leftrightarrow  \  (x^A:A)\in\Gamma'$
\end{enumerate}


\item
If $\Gamma$ is a context of $\LAMBDA$, then $\Gamma\setminus\{x^T:T\}$ is the context obtained
by removing $x_i^{A_i}:A_i$ from $\Gamma$ if $x_i^{A_i}=x^T$. 
If $x \not \in \FV(\Gamma)$ then $\Gamma\setminus\{x^T:T\} = \Gamma$.

\end{enumerate}
\end{definition}

We have $\Gamma \subseteqsim \Gamma'$ if and only if
if there is a (unique) map $\phi:\{1,\ldots,n\} \rightarrow \{1,\ldots,n'\}$
such that $x_{i}=x'_{\phi(i)}$ and $A_{i}=A'_{\phi(i)}$ for all $i \in \{1,\ldots,n\}$.
We have  $\Gamma \sim \Gamma'$ if and only if  $\Gamma \subseteqsim \Gamma'$
and  $\Gamma \supseteqsim \Gamma'$ if and only if $\Gamma$, $\Gamma'$ are permutation
each other if and only if the map $\phi$ above is a bijection.


%12:38 17/04/2024
%15:37 17/04/2024

%From the context for a term we can define a context for each subterm of the term.


%21:26 19/04/2024

%\begin{definition}[Inherited Contexts of $\LAMBDA$]
%
%Given any context $\Gamma$, any $t \in \Lambda$ and any subterm chain 
%$\pi = (t_1, \ldots, t_n) \in \Tree(t)$, we define a unique inherited context for $t_n$ in $\pi$.
%The inherited context is obtained by repeatedly adding $x^T:T$ to the context whenever we
%cross a term $t_i = \lambda x^T.u_i$, while simultaneously removing $x^T:T$ from the previous
%context, if it was there.
%%08:00 20/04/024
%
%\begin{enumerate}
%
%\item
%$t$ has inherited context $\Gamma$.
%
%\item
%Any binder on $x$ subtracts the variable $x$ from the context of its \emph{last} argument:
%if $t = \lambda x^T.u, \cond(f,g)$ has inherited context $\Delta$, 
%then $u$ and $g$ have context $\Delta \setminus \{x^T:T\}, x^T$, 
%while $f$ has  inherited context $\Delta$.
%
%\item
%In any other case the context of a term and of the immediate subterm are the same:
%ff $t=\Succ(u), f(a)$ have inherited context $\Delta$,
% then $u,f,a$ have  inherited context $\Delta$.
%\end{enumerate}
%We abbreviate \emph{`` inherited context from $\Gamma$''} with \emph{context}
%when $\Gamma$ is fixed.
%\end{definition}



%The scope of the binder $\lambda x^T.t$ is $t$.
%The scope of the binder $\cond(f,g)$ is $g$ ($f$ is \emph{not} in the scope of $\cond(f,g)$).

We define typing rules for terms of $\LAMBDA$ and the subset $\WTyped$ of well-typed terms.
We consider a term well-typed if typing exists and it is unique for the term and for all its subterms.

The typing rules are the usual ones but for %the conditional binder $\cond$, and for 
the rule $\ap$ for an application $t(u)$, which we split in two sub-rules, $\apvar$
and $\apnotvar$, according if $u$ is a variable or is not a variable.
%$\apvar$ corresponds to an $\eta$-expansion and it introduces a global variable name $x^T$
%for the first argument of $t$. 
%As we said, 
We need to insert this extra information $t$ in typing because it is importat for checking termination
of the computation of $t(u)$, as we will explain later.

We also remark that we introduced a unique \emph{term notation}
for application: we write $\ap(t,u)$ no matter if $u$ is a variable or not.

%We have a single structural rule  $\struct_f$, which can be used for:
% weakening, variable permutation and variable renaming. 
We have a a single structural rule $\weak$ for extending a context $\Gamma$ to a context 
$\Gamma' \supseteqsim \Gamma$. When $\Gamma' \sim \Gamma$ (when 
$\Gamma'$, $\Gamma$ are permutation each other), 
the rule $\weak$ can be used for variable permutation.
Variable renaming for a term $t[\vec{x}]$ can be obtained by writing 
$(\lambda \vec{x}.t[\vec{x}])(\vec{x'})$. 
Therefore we do not assume having a primitive rule for renaming. 
The lack of a renaming rule is a difference with the circular syntax for inductive proofs.

%11:56 29/04/2024

\begin{definition}[Typing rules of $\LAMBDA$]
Assume $\Gamma = {x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_1$ is a context. 
%$\Delta = y_1:B_1, \ldots, y_n:B_m$ are sequents of length $n$, $m$ respectively. Suppose
%$f:\{1, \ldots, n\} \rightarrow \{1, \ldots, m\}$ is any injection, compatible with types
%in $\Gamma$, $\Delta$: we assume $A_i = B_{f(i)}$ for all $1 \le i \le n$.

\begin{enumerate}
%\item
%$\struct_f$-rule.
%If $t: \Gamma \vdash T$ then $t[ y_{f(1)}/x_1, \ldots,  y_{f(n)}/x_n]:\Delta \vdash T$
\item
A rule is a list of $n+1$ typing judgements: 
$\Gamma \vdash t_1:A_1, \ldots, \Gamma \vdash t_n:A_n, \Gamma \vdash t : A$.
The first $n$ sequents are the premises of the rule, the last sequent is the conclusion of the rule.
\item
We read the rule above: \emph{``if $\Gamma \vdash t_1:A_1, \ldots, \Gamma \vdash t_n:A_n$
then $\Gamma \vdash t : A$"}.
\end{enumerate}

We list the typing rules of $\LAMBDA$.

\begin{enumerate}

\item
$\weak$-rule (Weakening).
If $\Gamma \vdash t:T$ and $\Gamma \subseteqsim \Gamma'$
then $\Gamma' \vdash t : T$

\item
$\var$-rule.
If $x^A \in \Gamma$ then $\Gamma \vdash x^A:A$.



\item
$\lambda$-rule.
If $\Gamma, x^A:A \vdash b: B$
then $ \Gamma \vdash \lambda x^A.b :A \rightarrow B$.

\item
$\apvar$-rule.
If $\Gamma \vdash f: A \rightarrow B$ and  $(x^A:A)\in  \Gamma$
then $\Gamma \vdash f(x^A) :  B$.

\item
$\apnotvar$-rule.
If $\Gamma \vdash f:A \rightarrow B$ and $\Gamma \vdash a:A$
and $a$ is \emph{not} a variable then $\Gamma \vdash f(a) : B$.

\item
$0$-rule.
$\Gamma \vdash 0: \N$

\item
$\Succ$-rule.
If $\Gamma \vdash t:\N$ then $\Gamma \vdash \Succ (t):\N$.

\item
$\cond$-rule.
If $\Gamma \vdash  f :T$ and  $\Gamma \vdash g : \N \rightarrow T$ 
then $\Gamma \vdash \cond(f,g) : \N \rightarrow T$.
\end{enumerate}
We abbreviate $\nil \vdash  t:A$ ($t:A$ in the empty context) with $\vdash t:A$. 
We write the set of rules of $\LAMBDA$ as
$$
\Rule = 
\{r \in \Seq \cup \Seq \cup \Seq^2 | r \mbox{ instance of some rule of }\LAMBDA\}
$$
\end{definition}

A rule is uniquely determined from its conclusion, provided we know whether the rule is a weakening or not.

\begin{proposition}[Rules and subterms]
\label{proposition-rules-subterms}
Assume $r, r' \in \Rule$ have conclusion $\Gamma \vdash t:A$, $\Gamma' \vdash t':A'$
respectively.
\begin{enumerate}
\item
If $r, r'$ are weakening rules and $\Gamma \vdash t:A = \Gamma' \vdash' t':A'$ then $r = r'$.
\item
If $r, r'$ are non-weakening rules and $\Gamma \vdash t:A = \Gamma' \vdash' t':A'$ then $r = r'$.
\item
If $r$ is not a weakening and 
the premises of $r$ are some $\Gamma_1 \vdash t_1:A_1, \ldots, \Gamma_n \vdash t_n:A_n$,
then the list of immediate subterms of $t$ is exactly $t_1, \ldots, t_n$.
\end{enumerate}
\end{proposition}

From the typing rules we define the proofs that a term is well-typed. 
Proofs are binary trees on the set $\Rule$, each node is associated to a typing judgement which is
a consequence of the typing judgements associated to the children node under some rule $r \in \Rule$
of $\LAMBDA$.

%12:55 29/04/2024

This is the formal definition of proof.

\begin{definition}[Well-typed term of $\LAMBDA$]
Assume $\Pi=(T,\phi)$ is a binary tree labeled on $\Rule$.
Assume $\Gamma$ is a context of $t$ (i.e, $\FV(t) \subseteq \Gamma$) and $A \in \Type$ 

Then we write $\Pi: \Gamma \vdash t:A$, and we say that $\Pi$ is a proof of $\Gamma \vdash t:A$ if:

\begin{enumerate}

\item 
$\phi(\nil) = \Gamma \vdash t:A$.

\item
Assume that
\begin{enumerate}
\item
$l \in T$ is labeled with $\phi(l) = \Delta \vdash u: B$.
\item
\item
The children of $l$ in $T$ are labeled 
$\Delta_1 \vdash u_1: B_1 = \phi(l \conc (1)), \ldots, \Delta_n \vdash u_n: B_n = \phi(l \conc (n))$ \end{enumerate}
Then for some rule $r \in \Rule$ of $\LAMBDA$ we have
\[
 \infer[r]
 {  \Delta \prove u : B  }
 {
       {\Delta_1  \prove u_1:B_1}
       { \ \ \ \ldots \ \ \ }
	   {\Delta_n  \prove u_1:B_1}
 }
\]
\end{enumerate}

\end{definition}


Eventually we define the well-typed terms of $\LAMBDA$.

\begin{definition}[Well-typed term of $\LAMBDA$]
\mbox{}
\begin{enumerate}
\item
$\Gamma \vdash t:A$ is true if and only if $\Pi:\Gamma \vdash t:A$ for some $\Pi$.
\item
$t \in \LAMBDA$ is well-typed if and only if $\Pi:\Gamma \vdash t:A$ for some \emph{unique} $A$
and some context $\Gamma \supseteqsim \FV(t)$.
\item
$\WTyped$ is the set of well-typed $t \in \LAMBDA$.
\end{enumerate}
%A proof $\Pi:\Gamma \vdash  t :T$ is canonical if all $\weak$-rules
%\begin{enumerate}
%\item
% either follow some $\lambda$-rule for a term $\lambda x^T.b$, and they introduce $x^T$ in the context,
%\item
%or follow some $\cond$-rule for a term $\cond(f,g)$, and and they introduce $x^\N$ in the context,
%\end{enumerate}
\end{definition}

We provide some examples of well-typed and not well-typed terms.
%23:30 23/04/2024
Some term in $\LAMBDA$ has no type, like the application $0(0)$ of the non-function $0$. 
Some term in $\LAMBDA$ has more than one type.
For instance if $t=u(0)$ and $u=\cond(t,u)$ 
we can prove $\vdash t:A$ for all types $A \in \Type$. 
The subterms of $t$ are $\{t, u, 0\}$ and a proof $\Pi: \vdash t:A$ is
\[
 \infer[\apnotvar]
 {  \prove t : A  }
 { \infer[\cond]{\prove u:\N \rightarrow A}{
           \infer[]
                  {\prove t : A  }
                  {\ldots}
           { \ \ \ \ \ \ }  &
           \infer[]
                  {\prove u : \N \rightarrow A  }
                  {\ldots} 
       }
       { \ \ \ \ \ \ } &
	   {\infer[0]{\prove 0:\N}{}}
  }
\]
Formally, the typing proof $\Pi=(T,\phi):\vdash t:A$ 
is defined by $\universe{\Pi}=\universe{t}$ and:
\begin{enumerate}
\item
$\Label(\Pi,l)=(\vdash A)$ \ \ \ \ \ \ \ for all $l \in \universe{t}$ such that  $t \restr l = t$,
\item
$\Label(\Pi,l) = (\vdash \N \rightarrow A)$  for all $l \in \universe{t}$ such that $t \restr l = u$,
\item
 $\Label(\Pi,l)=(\vdash\N)$ \ \ \ \ \ \ \  for all $l \in \universe{t}$ such that $t \restr l = 0$. 
\end{enumerate}
%09:06 24/04/2024

A term with at least two types has the leftmost branch infinite, as it is the case for $t$ above.
We will prove that if \emph{all} subterms of a term have the leftmost branch finite, then the term 
has at most one type. If the term is also regular then we can decide if the typing proof exists and 
if it exists we can compute it, in quadratic time in the size of the graph representing the term.
Well-typed terms are closed by substitution.

%10:26 20/04/2024
%13:49 29/04/2024
Our goal is to provide a set of well-formed term for $\LAMBDA$ and interpret them as partial functionals.
Some terms, those satisfying the global trace condition (to be introduced later) will be total functionals.
Our first step is to provide reduction rules for $\LAMBDA$.

%18:14 27/03/2024

\begin{definition}[reduction rules for $\LAMBDA$]
\mbox{}
\begin{enumerate}

\item
$\reduces_\beta$: $(\lambda x^A.b)(a) \reduces_\beta b[a/x]$

\item 
$\reduces_\cond$: $\cond(f,g)(0) \reduces_\cond f$ and
$\cond(f,g)(\Succ (t)) \reduces_\cond g(t)$.

\item
$\reduces$ is the context and transitive closure of $\reduces_\beta$ and $\reduces_\cond$

\item
$t \sim u$ if and only if there is some $v \in \LAMBDA$ such that $t \reduces v$ and $u \reduces v$.

\item
The $\cond$-depth of a node $l=(i_1, \ldots, i_n) \in t$ 
is the number of $1 \le h < n$ such that $(i_1, \ldots, i_h)$ has label $\cond$
 and $i_{h+1} = 2$
(such that $l$ occurs in the right-hand-side of a $\cond$).

\item
We say that $t \reduces_\safe u$, or that $t$ reduces safely to $u$,  
if we only reduce on nodes of $\cond$-depth $=0$.
%We call \emph{unsafe} a reduction inside any $\cond(f,g)$.

\item
A term is safe-normal if all its redexes (if any) have $\cond$-depth $>0$.
\end{enumerate}
\end{definition}

%09:19 24/04/2024
%14:00 29/04/2024

An example. Let $u = \cond. (0, (\lambda z.u)(z) )$, where we omitted the type superscript
of $z$ because it is irrelevant. Then $u$ is safe-normal, because
all redexes in $u$ are of the form  $(\lambda z.u)(z)$ and in the right-hand-side of a $\cond$. 
However, the tree form of $u$ has the following branch:
$$
u, \ \ \ 
(\lambda z.u)(z), \ \ \ 
\lambda z.u, \ \ \ 
u, \ \ \ \ldots
$$
This branch is cyclic, infinite,
and it includes infinitely many $\beta$-redexes.

The reason for forbiding
reductions in the right-hand-side $\cond(f,g)$ is that through branches crossing the right-hand-side
of some $\cond$ we will-express fixed-point equations.
Reductions on fixed-point equations can easily loop, and we consider them ``unsafe". 
For this reason, we first considered the minimum possible of reductions of the form:
$\cond(f,g)(0) \reduces_\cond f$ and
$\cond(f,g)(\Succ (t)) \reduces_\cond g[t/x]$: only  those which are 
applied on maximal $\cond$-expression.
We considered no reduction inside the second argument of $\cond$.

In a second moment, 
by adding a restriction of \emph{fairness} on reduction strategies,
we will be able to recover strong normalization for most ``unsafe" reductions.

We include one example of safe $\cond$-reductions of a term $v(n)$ to a normal form. 
Assume $n \in \Num$ is any numeral and $v = \cond(0, v)$. There are only finitely many reductions
from $v(n)$ instead, and they are all safe. $v(n)$ $\cond$-reduces to $v(n-1)$, 
then we loop: $v(n-1)$ $\cond$-reduces to $v(n-2)$ and so forth.
After $n$ $\cond$-reductions we get $v(0)$. With one last $\cond$-reduction we get $0$ and we stop. 
Thus, the term $v(n)$ strongly normalizes in $(n+1)$-steps, in fact we have a unique reduction path of
length $(n+1)$ from $v(n)$.


\section{The trace of the cyclic $\lambda$-terms}
%19:34 27/03/2024
We introduce the set $\GTC$ of the set $\WTyped$ of well-typed terms of $\LAMBDA$ 
satisfying a condition call \emph{global trace condition} for all proofs $\Pi$ that the term $t$ is well-typed.

In order to define the global trace condition, 
we have to define a notion of trace for possibly infinite $\lambda$-terms, 
describing how an input of type $\N$ is used when computing the output.
The first step toward a trace is defining a notion of \emph{connection} between arguments
of type $\N$ in the proof that $t$ is well-typed. 
To this aim, we need the notions of \emph{list of argument
 types} and of \emph{index of atomic types} for a term.

We sketch the notion of connection through an example.
Assume 
$$
{x_1}^{A_1}:A_1,{x_2}^{A_2}:A_2 
\vdash 
t[x_1,x_2]:B_3 \rightarrow \N
$$
Then the list of argument types of $t$
is $A_1, A_2, B_3$. $A_1,A_2$ are arguments with names $x_1, x_2$, and $B_3$ is an unnamed
argument. The index of an $\N$-argument of $t$ is any $j \in \{1,2,3\}$ such that $A_j=\N$
or $B_j=\N$ respectively.

Remark that for an open term $ t[x_1,x_2]$ we list as ``argument types'' also the
types $A_1, A_2$ of the free variables. We motivate this terminology:
in a sense, $t$ is an abbreviation of the closed term $t' = \lambda  
{x_1}^{A_1},{x_2}^{A_2}.t: (  A_1,A_2,B_3 \rightarrow \N )$, and the argument types of $t'$ are
$A_1, A_2, B_3$ and they include $A_1, A_2$. 



\begin{definition}[List of argument types of a term]
Assume that $\vec{A} = A_1, \ldots, A_n$, $\vec{B}=B_{n+1}, \ldots, B_{n+m}$, 
$\Gamma = \{\vec{x}:\vec{A}\}$,
and $\Gamma \vdash t: \vec{B} \rightarrow \N$.

\begin{enumerate}
\item
The \emph{list of argument types} of $t$ is $\vec{C} = \vec{A},\vec{B}$. 

\item
$A_1, \ldots, A_n$ are the \emph{named arguments}, with names $x_1, \ldots, x_n$.

\item
$B_{n+1}, \ldots, B_{n+m}$ are the \emph{unnamed arguments}.

\item
An \emph{index of an $\N$-argument} 
of $t$ is any $j \in \{1, \ldots, n+m\}$ such that $C_j = \N$.

\end{enumerate}
\end{definition}

We now define the connection between $\N$-argument of subterms of $t$
in a proof $\Pi: t:\Gamma \vdash A$ of  $\LAMBDA$. 
The definition of  atom connection for a syntax including the binder $\lambda$ 
is the main contribution of this paper. 
%Two $\N$-argument are in
%connection if and only if they receive the same global input: local input are ignored.
%In many cases two corresponding argument types have the same index, but if we insert or remove
%free variables or arguments the index may change.
Before providing the general definition, we discuss the notion of connection through examples. 
We draw in the same color two $\N$-argument which are in connection. 
\begin{Eg}\label{eg:0}\rm
An example of  atom connection for some instance of the $\weak$-rule.
\[
\infer[(\weak)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}, x_3:\bfColor{oldgold}{\N}
					\prove t : \bfColor{orange}{\N} \rightarrow \N}
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N} 
					\prove t : \bfColor{orange}{\N} \rightarrow \N}
\]
\end{Eg}
Remark that the type $\N$ of the variable $x_3$, colored in \bfColor{oldgold}{old gold} and 
introduced by weakening, is in connection with no type in the rule $\weak$.

%20:13 15/04/2024
\begin{Eg}\label{eg:1}\rm
An example of  atom connection for some instance of the $\apnotvar$-rule.
We assume that $a$ is \emph{not} a variable.
\[
\infer[(\apnotvar)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove f(a) : \bfColor{orange}{\N} \rightarrow \N}
    {
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove f : \bfColor{oldgold}{\N}, \bfColor{orange}{\N} \rightarrow \N}
      {\ \ \ \ \ \ }
      {   {x_1} : \bfColor{red}{\N}, x_2: \bfColor{blue}{\N}
					\prove a : \N}
	}
\]
\end{Eg}
Remark that the first unnamed argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
is in connection with no argument in the rule $\apnotvar$.
The reason is that in the term $f(a)$,
the first argument of $f$ receives a value from the value $a$ which is local to the term $f(a)$,
does not receive a value from outside the term.
However, the first argument of $f$ can be in connection with some argument higher in the typing proof. 
%13:21 15/04/2024

We postpone examples with the rule $\apvar$.

\begin{Eg}\label{eg:2}\rm
An example of  atom connection for the rule $\cond$.
\[
\infer[(\cond)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove \cond(f,g) : \bfColor{oldgold}{\N} \rightarrow \N}
    {
      {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove f : \N}
           {\ \ \ \ \ \ }
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}, x  : \bfColor{oldgold}{\N} 
					\prove g : \N}
    }
\]
\end{Eg}
Remark that the first unnamed argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
is in connection the type of the free variable $x$ in the second premise (the premise with $g$),
but it is in connection with no argument in the first premise (the premise with $f$).


\subsection{A formal definition of connection}
The definition of connection requires to define an injection 
$$
\ins:\N,\N \rightarrow\N
$$
We set $\ins(p,x)=x+1$ if $x \ge p+1$, and $\ins(p,x)=x$ if $x\le p$.
The role of $\ins$ is inserting one fresh index $p+1$ for a new argument type higher in the proof
connected to no argument in the conclusion.

\begin{definition}[Connection in a proof of  $\LAMBDA$]
Assume $\vec{A} = A_1, \ldots, A_n$, $\vec{B}=B_1, \ldots, B_m$, $\Gamma = \vec{x}:\vec{A}$,
and $\Gamma \vdash t:\vec{B} \rightarrow \N$.

For each $\N$-argument $k$ in $t$, for $t'=t$ or $t'$  immediate subterm of $t$ 
each $\N$-argument $k'$ in $t'$ we define the relation: ``$k',t'$ the successor of $k,t$". We require:
\begin{enumerate}
\item
if $t$ is obtained by a rule $\weak$ from $t'=t$, described by a map $\phi:\Gamma \rightarrow \Delta$,  
then $k = \phi(k')$.
\item
if $t=f(a)$ is obtained by a rule $\apnotvar$ (i.e., $a$ is not a variable) and $t'=f$ 
then $k' = \ins(n,k)$. If $t'=a$ then $k'=k$ and $k' \le n$.
\item
if $t=f(a)$ is obtained by a rule $\apvar$ (i.e., $a$ is not a variable) and $t'=f$ 
then $k' = \ins(n,k)$ and $k' > n$ or $k'=k$ and $k' \le n$.
\item
if $t=\cond(f,g)$ and $t'=f$ 
then $k' = \ins(n,k)$. If $t'=g$ then $k'=k$.
\end{enumerate}
We require $k = k'$ in all other cases, 
which are: $\Succ $, $\lambda$. 
\\
No connection is defined for the rules $\var$, $0$.
\end{definition}

Below we include some examples. 
We draw in the same color two $\N$-argument which are in connection. 


\begin{Eg}\label{eg:3}\rm
Atom connection for $\apvar$.
We assume that $x$ is a variable.
\[
\infer[(\apvar)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}, x  : \bfColor{oldgold}{\N}
					\prove f(x) : \bfColor{orange}{\N} \rightarrow \N}
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove f : \bfColor{oldgold}{\N}, \bfColor{orange}{\N} \rightarrow \N}
\]
\end{Eg}
Remark that the first unnamed argument of $f$ (colored in \bfColor{oldgold}{old gold}) 
in the premise is in connection with the last variable type in the conclusion of the rule.

\begin{Eg}\label{eg:4}\rm
Atom connection for  $\lambda$-rule.
We assume that $x$ is  a variable.
\[
\infer[(\ap)]
{  {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}
					\prove \lambda x.b : \bfColor{oldgold}{\N} \rightarrow \N}
	  {   {x_1} : \bfColor{red}{\N},{x_2} : \bfColor{blue}{\N}, x  : \bfColor{oldgold}{\N}
					\prove b : \N}
\]
\end{Eg}
Remark that the first unnamed argument of $\lambda x.b$ (colored in \bfColor{oldgold}{old gold}) 
in the conclusion is in connection with the last variable type in the premise of the rule.
\\

Summing up, when
we move up in a $\apvar$-rule, the type of last free variable corresponds to the type of the first
unnamend argument.
When  we move up in a $\lambda$-rule it is the other way round. 

The connection on $\N$-arguments in a proof $\Pi:\Gamma\vdash t:A$ defines a graph $\Graph(\Pi)$ 
whose nodes are all pairs $(k,u)$, with $u$ subterm of $t$ and $k$ index of some $\N$-argument of  $u$.
$\Graph(\Pi)$ is finite when $t$ is regular.
We define a trace as a (finite or infinite) path in the graph $\Graph(\Pi)$.

\begin{definition}[Trace for well-typed terms in $\LAMBDA$]
Assume $\Pi$ is any typing proof of $t \in \WTyped$.
\begin{enumerate}
\item
A path of $\Pi$ is any finite or infinite branch $\pi =(i_0, \ldots, i_n, \ldots)$ of $\Pi$.

\item
Assume $\pi =(t_0, \ldots, t_n, \ldots)$ is a path of $\Pi$, finite or infinite. 
A finite or infinite \emph{trace} $\tau$ of $\pi$ in $\Pi$ is a list 
$\tau =( (k_m,t_m), \ldots, (k_n,t_n), \ldots)$ such that for all $i=m,\ldots, n,\ldots$:
\begin{enumerate}
\item
$k_i$ is an index of some $\N$-argument of $t_i$
\item
if $i+1$ is an index of $\tau$ then $(k_{i+1},t_{i+1})$ is connected with $(k_i, t_i)$ in $\Pi$.
\end{enumerate}

\end{enumerate}
\end{definition}

%20:50 15/04/2024
%10:35 24/04/2024
%12:28 30/04/2024

\section{The circular system $\CTlambda$}
We define a subset $\CTlambda$ of the set $\WTyped$ of well-typed term,
by adding the global trace condition and regularity. 
For the terms of $\CTlambda$ we will prove
strong normalization, church-rosser for terms of type $\N$, and the fact that every term of type
$\N$ is a numeral. 
As a consequence, all terms $\CTlambda$ will be interpreted as total functionals. 

From the $\N$-argument connection we define the global trace condition and the set of 
terms of $\CTlambda$.


\begin{definition}[Global trace condition and terms of $\CTlambda$]
Assume $\tau =( (k_m,t_m), \ldots, (k_n,t_n), \ldots)$ 
is a trace of a path $\pi = (t_1, \ldots, t_n, \ldots)$ of $t \in \WTyped$. Assume $i=m,\ldots, n$.
\begin{enumerate}
\item
$\tau$ is progressing in $i$ if $t_i=\cond(f,g)$ for some $f$, $g$,
and $k_i$ is the index of the first \emph{unnamed} argument the $\cond$-rule, 
otherwise $\tau$ is not progressing in $i$.

\item
$t$ satisfies the global trace condition if for some typing proof $\Pi$,
of $t$, for all infinite paths $\pi$ of $t$ in $\Pi$,
there is some infinitely progressing path $\tau$ in $\pi$ and $\Pi$.

\item
Terms of $\CTlambda$ are all well-typed terms which are regular trees (having finitely many subtrees), 
and satisfy the global trace condition.

\end{enumerate}
\end{definition}

The notion of global trace condition is defined through a universal quantification on proof 
$\Pi:\Gamma \vdash t:A$, and proofs $\Pi$ are possibly infinite objects and they form 
a non-countable sets.
Therefore we would expect that the global trace condition is not decidable. 
Surprisingly, global trace is decidable in polynomial space in $t$. The reason is that is some proof satisfies
the global trace condition then all proofs do, and for regular terms there is a typing proof
which is a finite graph and for which the global trace condition is decidable.

We believe that the global trace condition should be decidable quite fast
for realistic $\lambda$-terms.


\section{Examples of terms of $\CTlambda$}

\subsection{The sum map}
%\Daisuke{Add sum (start)}
A first example of term of  $\CTlambda$. 
In this example, the type superscript $\N$ of variables $x^\N, z^\N$ is omitted.
We provide an infinite regular term $\Sum$ computing the sum on $\N$,
defined by $\Sum = \lambda x.\cond(x,\lambda z.\Succ(\Sum(x)(z)))$.
This term is regular because it has finitely many subterms: 
$$
\Sum, \  \  \ \cond(x,\lambda z.\Succ(\Sum(x)(z))), 
\  \  \ x, \  \  \ \lambda z.\Succ(\Sum(x)(z)),  \  \  \ \Sum(x)(z), \  \  \ \Sum(x)
$$
This term is well-typed by the following circular derivation, in which we have a back edge from the 
$\bfColor{oldgold}{\dagger}$ above to the $\bfColor{oldgold}{\dagger}$ below.
We colored in \bfColor{oldgold}{old gold} one sequence of atoms $\bfColor{oldgold}{\N}$ 
(one trace of the proof).
The colored trace is the unique infinite trace, it is cyclic and it is infinitely progressing.
We marked $\bfColor{oldgold}{ \spadesuit}$ the only progress point of the only infinite trace.
The progress point is repeated infinitely many times.
\[
\infer[\lambda]{
  \vdash \Sum:\N, \bfColor{oldgold}{\N} \rightarrow \N 
   \ \ \ (\bfColor{oldgold}{\dagger})
}{
  \infer[\cond]{
    x : \N \vdash 
    \cond(x,\lambda z.\Succ(\Sum(x)(z))): \bfColor{oldgold}{\N} \rightarrow \N
  }{
    \infer[\var]{
      x : \N \vdash x
    }{}
    &
    \infer[\Succ]{
      x:\N, z : \bfColor{oldgold}{\N} 
      \vdash \Succ(\Sum(x)(z)): \N  
        \ \ \ (\bfColor{oldgold}{ \spadesuit})
    }{
      \infer[\apvar]{
       x:\N, z : \bfColor{oldgold}{\N} 
       \vdash \Sum(x)(z): \N
      }{
         \infer[\apvar]{
       x:\N, z : \N
       \vdash \Sum(x): \bfColor{oldgold}{\N} \rightarrow \N
         }{
         \infer[\weak]{
         x:\N, z : \N
         \vdash \Sum: \N, \bfColor{oldgold}{\N} \rightarrow  \N
          }{
         \infer{\vdash \Sum: \N, \bfColor{oldgold}{\N} \rightarrow \N 
           \ \ \ (\bfColor{oldgold}{\dagger})}{\ldots}
          }
        }
      }
    }
  }
}
\]

%
%\begin{tikzpicture}
%  %\draw [help lines] (-3,-1) grid (9,7);
%  \coordinate (a) at (0,0) node at (a) {A};
%  \coordinate (c) at (0,5) node at (c) {C};
%  \draw (0,0) -- (0:2cm);
%  \draw (0,0) -- (30:3cm);
%  \draw (0,5) -- +(0:2cm);
%\end{tikzpicture}

%\Daisuke{Add sum (end)}\\

%10:43 16/04/2024

\subsection{The Iterator}
A second example. We define a term $\Iter$ of  $\CTlambda$ computing the iteration of maps on $\N$.
The term $\Iter$ is a normal term of type $(\N \rightarrow \N), \N,\N \rightarrow \N$ such that
$\Iter(f,a,n)=f^n(a)$ for all numeral $n \in \Num$. 
We have to solve the equations:

\begin{enumerate}
\item
$\Iter(f,a,0) \sim a$ 
\item
$\Iter(f,a,\Succ (t)) \sim f(\Iter(f,a,t))$
\end{enumerate}

where $f$, $a$ abbreviate $f^{\N\rightarrow\N}$ and $a^\N$.
We solve them with $\Iter = \lambda f, a.\iter$
where 
$$
\iter = \cond (a, \lambda x.f(\iter(x))):\N \rightarrow \N
$$ 
is a term in the context $\Gamma = (f:\N \rightarrow \N, a:\N)$.


\begin{proposition}
$\Iter \in \Reg \cap \WTyped \cap \GTC = \CTlambda$.
\end{proposition}

\begin{proof}
The term $\Iter$ is well-typed and regular by definition. 
We check the global trace condition. 
\\
We follow the unique infinite trace $\tau$ of the last unnamed argument $\N$ of $\Iter$ 
in the unique infinite path $\pi$ of $\Iter$. 
The trace $\tau$ moves to the first unnamed argument of $\lambda a.\iter$, 
then to $a:\N$ in the context of $\iter$.
Then the infinite path $\pi$ moves in this order to:
 $\lambda x.f(\iter(x))$, $f(\iter(x))$, $ \iter(x)$, $\iter$
In the meanwhile, $\tau$ progresses and moves to the first unnamed argument, 
then moves to $x$ in the context of $f(\iter(x))$,
then to $x$ in the context $\iter(x)$, and eventually to $x$ in the context of $\iter$.
%10:30 24/03/24
Now the infinite path $\pi$ loops, and at each loop the trace $\tau$ 
progresses once. We conclude that $\tau$ infinitely progresses.
\end{proof}

The proof above includes a type inference from the term $\iter$ to itself.
We draw the type inference in the picture below. 
We have a back edge from the 
$\bfColor{oldgold}{\dagger}$ on the top to the $\bfColor{oldgold}{\dagger}$ in the bottom,
and we marked $\bfColor{oldgold}{ \spadesuit}$ the only progress point, which is cyclically repeated
in $\tau$.
We abbreviate $\Gamma = (f:\N \rightarrow \N, a:\N)$.
\[
%\infer[\lambda]{ %opening: \infer[\lambda]
%  \vdash \Iter:(\N \rightarrow \N), \N, \bfColor{oldgold}{\N} \rightarrow \N
% }{
%  \infer[\lambda]{ %opening: \infer[\lambda]
%  f:\N \rightarrow \N
%  \vdash \lambda a.\iter:\N, \bfColor{oldgold}{\N} \rightarrow \N
%  }
{
    \infer[\cond]{ %opening: \infer[\cond]
      \Gamma 
      \vdash \iter: \N, \bfColor{oldgold}{\N} \rightarrow \N 
        \ \ \ (\bfColor{oldgold}{ \spadesuit}, \bfColor{oldgold}{\dagger})
     }{ 
         \infer[\var]{
       \Gamma 
      \vdash a:\N}{}
     &
        {\ \ \ \ \ \ }
        {\infer[\lambda] %opening: \infer[\lambda]
         {
         \Gamma
          \vdash \lambda x.f(\iter(x)):\bfColor{oldgold}{\N} \rightarrow \N
         }{
         \infer[\ap]{ %opening: \infer[\ap]
           \Gamma, x:\bfColor{oldgold}{\N}
          \vdash f(\iter(x)):\N
           }{
          \infer[\var]{
       \Gamma, x:\N 
      \vdash f:\N}{}
           {\ \ \ \ \ \ \ \ \ \ \ \ }
           {\infer[\apvar] %opening: \infer[\apvar]
            {\Gamma, x:\bfColor{oldgold}{\N}
        \vdash \iter(x): \N \rightarrow \N 
             }{
          \infer[\weak]{\Gamma, x:\N
                                 \vdash \iter: \N, \bfColor{oldgold}{\N} \rightarrow \N}
                                {\infer[]{\Gamma
                                 \vdash \iter: \N, \bfColor{oldgold}{\N} \rightarrow \N
                                  \ \ \ (\bfColor{oldgold}{ \dagger})}{\ldots}          
             }
           }
          }
        }%closing: \infer[\apvar]
      }%closing: \infer[\ap]
    }%closing: \infer[\lambda]
   }%closing: \infer[\cond]
 }%closing: \infer[\lambda]
%}%closing: \infer[\lambda]
\]




\subsection{The Interval Map}
A third example. We simulate lists with two variables $\nil:\alpha$ and 
$\cons:\N,\alpha \rightarrow \alpha$. We recursively define a notation for lists by $[]=\nil$,
$a @ l=\cons(a,l)$ and $[a,\vec{a}] = a @ [\vec{a}]$. We add no elimination rules for lists, though,
only the variables $\nil$ and $\cons$. Elimination rules are not required in our example.

We will define a term $\Interval$ with one argument $f:\N \rightarrow \N$ and three argument
$a,x,y:\N$ (we skip type superscripts), such that 
$$
\Interval(f,a,n,m) \  \sim \ [f^n(a), f^{n+1}(a), \ldots, f^{n+m}(a)] \  : \ \alpha
$$ 
for all numeral $n,m \in \Num$. 
We have to to solve the recursive equations 
$$
\Interval(f,a,n,0)  \sim [f^n(a)]
\ \ \ \ \ \ 
\Interval(f,a,n,\Succ (m))  \sim f^n(a) @ \Interval(f,a,\Succ(n),m)
$$ 
Assume $\iter = \cond (a, \lambda x.f(\iter(x))):\N \rightarrow \N$ is the term
in the context $(f:\N\rightarrow\N, a:\N)$ defined 
in the previous sub-section: in particular, $\iter(n) \sim f^n(a)$ for all $n \in \Num$.
We solve the recursive equation for $\Interval$ with $\Interval = \lambda f,a.\interval$,
where 
$$
\interval:\N,\N \rightarrow \alpha
$$
is a term in the context $(f:\N\rightarrow\N, a:\N)$ defined by 
$$
\interval 
\ \ \ = \ \ \ 
\lambda x.\cond (\base,  \lambda y.\inductive),
$$
where the base case and the inductive case are
$$
\base 
\ \ \ =\ \ \  
[\iter(x)]
\ \ \ =\ \ \ 
\cons(\iter(x),\nil)
$$
$$
\inductive 
\ \ \ = \ \ \ 
\iter(x) @ \interval(\Succ(x))(y)
\ \ \ = \ \ \  
\cons(\ \iter(x), \ \interval(\Succ(x))(y) \ )
$$ 


\begin{proposition}
$\Interval \in \Reg \cap \WTyped \cap \GTC = \CTlambda$.
\end{proposition}

\begin{proof}
The term $\Interval$ is well-typed and regular by definition. We check the global trace condition.
Any infinite path $\pi$ either moves to $\iter$, for which we already checked the global trace condition,
or cyclically moves from $\interval$ to $\interval$.
We follow the unique infinite 
trace $\tau$ of the last unnamed argument $\N$ of $\Interval$ inside this infinite path.
The trace $\tau$ moves to the last unnamed argument $\N$ of  
$\interval:\N,\N \rightarrow \N$, then to the last unnamed argument of
$\cond (\ [\iter(x)],  \  \lambda y.\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )$.
In this step $\tau$ progresses, and moves to 
the first unnamed argument of $\lambda y.\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )$,
then to $y:\N$ in the context of $\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )$.
After one $\apvar$ rule, the trace $\tau$ reaches the unique unnamed argument of 
$(\lambda x.\interval)(\Succ(x))$, then the last unnamed argument $\tau$ of $\interval$. 
From $\interval$ the trace $\tau$ loop. Each time $\tau$ moves from $\interval$ to $\interval$
then $\tau$ progresses once. We conclude that $\tau$ infinitely progresses.
\end{proof}
%14:27 24/04/2024

The proof above includes a type inference from the term $\interval$ to itself.
We draw the type inference in the figure \ref{figure-term-interval}. 
In this figure, we include a back edge from the 
$\bfColor{oldgold}{\dagger}$ on the top to the $\bfColor{oldgold}{\dagger}$ in the bottom,
and we marked $\bfColor{oldgold}{ \spadesuit}$ the only progress point, which is cyclically repeated
in $\tau$.
We abbreviate 
$\Sigma = (\nil:\alpha, \cons:\N,\alpha \rightarrow \N)$
and
$\Gamma = \Sigma,(f:\N \rightarrow \N, a:\N)$.

%PROOF SNAPSHOT
\begin{figure}
\label{figure-term-interval}
\includegraphics[scale=0.6]{type-inference-term-interval.PNG}
\begin{center}\mbox{Figure \ref{figure-term-interval}}\end{center}
\end{figure}
%% LATEX SOURCE CODE THEN A SNAPSHOT 
%% THEN THE SNAPSHOT HAS BEEN MODIFIED IN WORD 
%% THEN A LAST SNAPSHOT
%  
%\[
%%\infer[\lambda]
%% {\Sigma\vdash \Interval:(\N \rightarrow \N),\N,\N,\bfColor{oldgold}{\N}\rightarrow\alpha}
%% {\infer[\lambda]
%%   {\Sigma,f:\N\rightarrow\N \vdash \lambda a.\interval:\N,\N,\bfColor{oldgold}{\N}\rightarrow\alpha}
%   {\infer[\lambda]  
%     {\Gamma \vdash \interval:\N,\bfColor{oldgold}{\N}\rightarrow\alpha
%          \ \ \ (\bfColor{oldgold}{ \spadesuit}, \bfColor{oldgold}{\dagger})}
%       {\infer[\cond]{\Gamma, x:\N 
%	\vdash 
%	\cond (\base,  \inductive )
%	:\bfColor{oldgold}{\N}\rightarrow\alpha}
%       {\infer[\apvar]{\Gamma, x:\N 
%	           \vdash 
%	           \base:\alpha}
%             {\infer[]{\Gamma, x:\N 
%	           \vdash 
%	           \cons(\iter(x)):\alpha \rightarrow\N}{\ldots}}
%            {\ \ \ \ \ \ }  &
%          \infer[\lambda]{\Gamma, x:\N 
%	           \vdash 
%	           \lambda y.\inductive : \bfColor{oldgold}{\N}\rightarrow\alpha}
%             {\infer[\apnotvar]{\Gamma, x:\N, y:\bfColor{oldgold}{\N} \vdash
%               \inductive : \alpha}
%            {\infer[]
%                     {\Gamma, x:\N, y:\N 
%                          \vdash \cons(\iter(x)):\alpha\rightarrow\N}{\ldots}
%               {\ \ \ \ \ \ }
%                     {\infer[\apvar]{\Gamma, x:\N, y:\bfColor{oldgold}{\N} 
%                          \vdash \interval(\Succ(x))(y):\alpha}
%                         {\infer[\apnotvar]{\Gamma, x:\N, y:\N 
%                          \vdash \interval(\Succ(x)):\bfColor{oldgold}{\N} \rightarrow\alpha}
%                              {\infer[\weak]{\Gamma, x:\N, y:\N 
%                          \vdash \interval:\N,\bfColor{oldgold}{\N} \rightarrow\alpha}
%                                {\infer[]{\Gamma 
%                          \vdash \interval:\N,\bfColor{oldgold}{\N} \rightarrow\alpha
%                           \ \ \ (\bfColor{oldgold}{\dagger})}
%              {\ldots}}}}}
%            }
%          }
%       }
%      }  
%    }
%%}
%\]

More comments about the term $\Interval$.
We have infinitely many nested $\beta$-reduction $(\lambda x. \ldots)(\Succ (x))$.
We can remove all of them in a single step. Inside the $\beta$-redex number $k$ we obtain a sub-term
$\iter[\Succ (x)/x]\ldots[\Succ (x)/x]$ (substitution repeated $k$ times).
The result is $\iter[\Succ ^k(x)/x] $.
The nested substitution produce infinitely many pairwise different sub-terms 
$\iter(\Succ ^k(x))$ for all $k \in \N$.
We need infinitely many steps to normalize all $\iter(\Succ ^k(x))$ to $f^k(I)$, 
even if we allow to reduce all $\beta,\cond$-redexes at the same time.
Also the normal form is not regular: it contains all terms $f^k(\iter(x))$ for $k \in \N$, hence
infinitely many pairwise different terms. 
%These infinite sub-terms are of a particulary simple form, though. 
%They are obtained by the repeating $k$ times the assignment $z:=f(z)$, then applying $z:=I$ once
%to the result.

In conclusion, 
$\Interval$ is some term of $\CTlambda$ which can be safely normalized, but which 
cannot be fully normalized in finite time, not even if we allow
infinite parallel reductions without any "safety" restriction. 
The normal form is produced \emph{only in the limit}
and it is \emph{not regular}. If we allow to reduce infinitely many nested existing
$\beta$-redexes in one step, also
the intermediate steps of the infinite reduction of $\Interval$ are not regular.

%16:32 30/04/2024

\section{Subject reduction for terms of $\CTlambda$ of type $\N$}
%\Daisuke{SR start}
\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
\\
\emph{(Here we should fill this part)}
\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
%\Daisuke{SR end}

%15:12 16/04/2024
%15:46 24/04/2024

\section{Weak normalization for closed terms of $\CTlambda$ of type $\N$}
\label{section-weak-normalization}
%\Daisuke{WN start}
In this section we prove that every closed term of $\CTlambda$
 (that is, well-typed, regular and with the global trace condition) normalizes with finitely many "safe" steps
to some numeral $n \in \N$.
In the following, we explicitly write $t[x_1,\ldots,x_n]$,
when each free variable in $t$ is some $x_i$, 
and, under this notation, we also write $t[a_1,\ldots,a_n]$ instead of $t[a_1/x_1,\ldots,a_n/x_n]$. 
We recall that we denote with $\Num$ the set of all numerals, namely the set of all terms of the form
$\Succ^n(0)$ for some $n\in \Nat$.

We define closed total terms as in Tait's normalization proof, and a subset of them, the values.
The only different between values and closed total terms 
is that if a value has type $\N$ then it is a numeral.

Here is an informal definition. Values of type $\N$ are exactly the numerals. 
Total terms $t$ of type $\N$ are
the closed terms of type $\N$ evaluating in at least one reduction path to a numeral. 
Hence total terms $t$ of type $\N$ include values of type $\N$. 
Closed total terms and values of type $t:\alpha$ (with $\alpha$ type variable) coincide, 
both are all closed terms.
Closed total terms and values of type $t:A \rightarrow B$ coincide, 
both are all the terms mapping values to total terms. 
An open term is total if all substitutions of free variables with values produce a \emph{closed total} term.

Below is the formal definition of values, closed total terms and total terms.

\begin{definition}[Values and total term]
  We define values and closed total terms on values by induction on types. 
  \begin{enumerate}
  \item
    A closed term $t:\N$ or is a \emph{value} if and only if $t \in \Nat$ ($t$ is some numeral).
  \item
    A closed term $t:\N$ is \emph{closed total}
    if and only if $t \safeReduces^* u$ for some $u\in \Nat$.
  \item
    Closed terms and values of type $t:\alpha$ (type variable) coincide, both are all closed terms.
   \item
    A closed term $t:A\rightarrow B$ is a \emph{value}
    if and only if $t(a)$ is closed total for any value $a:A$.
   \item
    Closed terms and values of type  $t:A\rightarrow B$ coincide.
   \end{enumerate}
   A term $t[\vec{x}]:C$ (i.e., whose free variables are in $\vec{x}:\vec{A}$), is
    \emph{total} if and only if $t[\vec{a}]$ is closed total for any values $\vec{a}$ of type $\vec{A}$.
\end{definition}

Assume $t[\vec{x}]:\vec{A}\rightarrow\N$ is a well-typed term of $\LAMBDA$ in the context 
 $\Gamma = \vec{x}:\vec{B}$.
 A \emph{value assignment} $\vec{v}$ for $t$ in $\Gamma$ is any vector 
$\vec{v}=\vec{u},\vec{a}:\vec{B}\vec{A}$ of closed values. We can assign values to  the sub-terms
in a path of a proof in a way compatible with traces. 

\begin{definition}[Trace-compatible Assignment]
Assume $\pi = (t_1, \ldots, t_n) \in \Tree(t)$ is any chain of immediate subterms from $t_1=t$,
and $\vec{v} = (\vec{v_1}, \ldots, \vec{v_n})$ 
 is any vector of value assigments, one for each $t_i$. 
$\vec{v}$ is \emph{trace-compatible}  if and only it satisfies the following condition:

  for all $j$  index of an $\N$-argument of $t_i$ assigned to $\Succ^{a}(0)$, 
  all $k$ index of an $\N$-argument of $t_{i+1}$ assigned to $\Succ^{b}(0)$, 
  if $j$ is connected to $k$ then:
 \begin{enumerate}
 \item
 if $j$ progresses to $k$ then $a=b+1$
 \item
 if $j$ does not progress to $k$ then $a=b$.
 \end{enumerate}

\end{definition}

If an infinite path has a trace-compatible assignment, then all traces of the path progress only finitely many times.

\begin{proposition}[Trace assigment]
\label{prop:trace_assign}
Assume $\Pi:\Gamma \vdash t:A$ and $\pi$ is an infinite path of $\Pi$ and
$\rho$ is a value assignment to $\pi$. Assume $n \in \Nat$.
\begin{enumerate}
\item
\label{prop:trace_assign1}
If an $\N$ argument $j$ of some $t_i \in \pi$ has value $\Succ^n(0)$ in $\rho$, then a trace
from $j$ progresses at most $n$ times.
\item
\label{prop:trace_assign2}
$t \not \in \GTC$.
\end{enumerate}
\end{proposition}

\begin{proof}
\begin{enumerate}
\item
%\label{prop:trace_assign1}
By definition of trace-compatible assignment, whenever the trace progresses, 
the numeral $n$ associated to the progressing argument decreases by $1$.
Whenever the trace does not progress, the numeral $n$ remains the same.
Thus, a trace from $j$ progresses at most $n$ times, as we wished to show.
\item
%\label{prop:trace_assign2}
By point \ref{prop:trace_assign1} above, 
no trace from any argument in any term of the branch $\pi$ of $\Tree(t)$ progresses infinitely many times.
By definition of $\GTC$, we conclude that $t \not \in \GTC$. 
\end{enumerate}
\end{proof}

Closed total terms are closed by safe reductions and by application. 

\begin{lemma}\label{lem:total_value}
  \begin{enumerate}
  \item\label{lem:total_value1}
    Let $t:A$ be a closed term and $t \safeReduces u$.
    If $u$ is total, then so is $t$.
  \item\label{lem:total_value2}
    Let $f:A \rightarrow B$ and $a:A$ be closed \emph{total} terms.
    Then so is $f(a)$.
  \item\label{lem:total_value3}
    Let $t[\vec{x}]:\vec{A}\rightarrow\N$ be a term,
    whose all free variables are $\vec{x}:\vec{B}$,
    and $\vec{u}:\vec{B}$ and $\vec{a}:\vec{A}$ be closed values.
    If all $t[\vec{u}]\vec{a}:\N$ are total, then $t[\vec{x}]$ is total. 
  \end{enumerate}
\end{lemma}
\begin{proof}
\begin{enumerate}

\item
  We show \emph{point \ref{lem:total_value1}}  by induction on $A$. 
By the subject reduction property, $u$ has type $A$.
\begin{enumerate}
\item
  We first show the first \emph{base case}, namely when $A =\N$.
  By the assumption, $u$ is closed total.
  By definition of $u$ closed total, we have $t \safeReduces u \safeReduces^* n$ for some $n\in\Num$. 
  Hence $t:\N$ is total.
\item
  We first show the second \emph{base case}, namely when $A =\alpha$.
  Both $t$ and $u$ are closed terms of type $\alpha$, therefore both are closed total terms.
\item
  We show the \emph{induction case}, namely when $A = (A_1\rightarrow A_2)$.
  Take arbitrary closed value $a:A_1$. Then we have $t(a) \safeReduces u(a)$ and 
  $u(a):A_2$ is total by the assumption that $u$ is total.
  Hence by the induction hypothesis $t(a)$ is total. 
  We obtain that $t:A_1\rightarrow A_2$ is total. 
\end{enumerate}

  \item
We show \emph{point \ref{lem:total_value2}} by case reasoning.
Assume that$f:A \rightarrow B$, $a:A$ are closed total terms, in order to prove
that $f(a)$  is closed total.

Assume $A$ is a variable type or an arrow type. 
Then $a:A$ is a value because values and closed total terms of type $A$
coincide, therefore $f(a):A$ is closed total by definition of closed total.

Assume $A=\N$. Then $a \safeReduces n$ for some $n \in \Num$ by definition of closed total.
$f(n)$ is closed total by definition of closed total. $f(a)$ is closed total by $f(a) \safeReduces f(n)$
and point \ref{lem:total_value2} above.

\item  
  We show \emph{point \ref{lem:total_value3}} by induction on the number $|\vec{A}|$ of
elements of $\vec{A}$.
\begin{enumerate}
\item
  The \emph{base case} $|\vec{A}| = 0$ is immediately shown by the definition.
\item
  We show the \emph{induction case}. Let $\vec{A} = A_0,\vec{A'}$.
  Take arbitrary values $\vec{u}:\vec{B}$, $\vec{a'}:\vec{A'}$, and $a_0:A_0$. 
  By the assumption, we have that $t[\vec{u}]a_0\vec{a'}:\N$ is closed total for all 
  vector of values $\vec{a'}$. 
  Then $t[\vec{u}]a_0:\vec{A'}\rightarrow\N$ is total 
  by the induction hypothesis on $\vec{A'}\rightarrow \N$.
  By definition $t[\vec{u}] : A_0,\vec{A'}\rightarrow\N$ is closed total,
  and so by definition $t[\vec{x}]$ is total, as we wished to show.
\end{enumerate}

\end{enumerate}
\end{proof}

%10:28 19/04/2024
%17:32 24/04/2024

Let $\Pi=(T,\phi)$ be a proof of $\Gamma\vdash t:A$ and $e$ be a node of $\Pi$, that is, a list  
$e=(e_1, \ldots, e_n) \in \universe{\Pi} = T$.
We write $\Gamma_n\vdash t_n:A_n = \Label(\Pi,e)$ for the
 label of the node $e$. We want to prove that all terms of $\GTC$ are total.

\begin{theorem}
  Assume $\Pi:\Gamma\vdash t:A$ (hence $t\in \WTyped$).
  If $t$ is \emph{not} total, then $t \not \in \GTC$, i.e.:
  there is some infinite path $(e_1, e_2, \ldots)$ of $\Pi$ with no infinite progressing trace. 
\end{theorem}

%19:01 16/04/2024
%18:11 30/04/2024

\begin{proof}
  Assume that $t$ is not total
  and $t: \vec{x}:\vec{D}\vdash\vec{A}\rightarrow\N$ 
  has a proof $\Pi=(T,\phi)$ in order to show that $t \not \in \GTC$.
  By Proposition \ref{prop:trace_assign}.\ref{prop:trace_assign2} it is enough to prove that
  $\Pi$ has some infinite path $\pi=(e_1, e_2, \ldots)$ 
  and some trace-compatible assignment $\rho$ for $\pi$.
  By \ref{lem:total_value3} of Lemma~\ref{lem:total_value},
  there exist closed values $\vec{a}:\vec{A}$ and $\vec{d}:\vec{D}$ such that
  $t[\vec{d}]\vec{a}$ is not total. 
  By induction on $i \in \N$, we construct an index $e_i \in \{1,2\}$ for each natural number $i$,
  and a value assignment $\vec{v_i} = (\vec{d_i},\vec{a_i})$ such that 
  $t_i = t \restr (e_1, \ldots, e_{i-1})$ is a subterm of $t$
  and $(\vec{v_1},\ldots,\vec{v_i})$ is a trace-compatible assignment for the node 
  $l_i = (e_1, \ldots, e_{i-1})$.
  We have to find some $e_{i} \in \{1,2\}$ such that:
  \begin{itemize}
  \item[(i)]
%15:38 19/04/2024
   $t_{i} = t \restr l_{i}$ is a subterm of $t$,
    $\Pi( ( l_{i} ) = \vec{x_{i}}:\vec{D_{i}}\vdash t_{i} : \vec{A_{i}}\rightarrow\N$, 
    and $e_{i}$ is any child node of $(e_1, \ldots, e_{i})$ in $\universe{\Pi}$; 
  \item[(ii)]
    $t_{i}$ is not total;
  \item[(iii)]
    $\vec{d_{i}}:\vec{D_{i}}$ and $\vec{a_{i}}:\vec{A_{i}}$ are closed values
    such that $t_{i}[\vec{d_{i}}]\vec{a_{i}}$ is not total;
  \item[(iv)]
    the value assignment 
    $\vec{d_1};\vec{a_1}$, \ldots, $\vec{d_{i}};\vec{a_{i}}$) is trace compatible.
    That is, if $i-1$ is a progress point, namely if $t_{i-1}$ is of the form $\cond(f,g)$ and $e_{i}=2$ 
    (hence $t_{i}$ is $g$),
    then $\vec{a_i} = \Succ(m')\vec{a'}$, $\vec{d_{i}} = \vec{d_i}m'$.
    %\Daisuke{mynote:write this more clearly}
  \end{itemize}
  
  We first define $(l_1,\vec{d_1},\vec{a_1})$ for the root node $t$ of $\Pi$.
  In this case $l_1 = \nil$ 
   and $(\vec{d},\vec{a})$ are values such that $t[\vec{d}](\vec{a})$ is not total.
  Points (i), (ii), (iii), (iv) are immediate.

  Next, assume that $(e_i,\vec{d_i},\vec{a_i})$ is already constructed.
  Then we define $(e_{i+1},\vec{d_{i+1}},\vec{a_{i+1}})$ by the case analysis on
  the last rule for the node $e_{i+1}$ in $\Pi$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPARENTLY THE CASE $\struct(f)$ CAN BE SIMPLIFIED TO WEAKENING-Stefano
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
\item
  The case of $\weak$, namely
  $\Label(\Pi,l_{i+1}) = t[y_{\theta (1)}/x_1,\ldots,y_{\theta (n)}/x_n]:\Delta\vdash \vec{A_i}\rightarrow\N$
  is obtained from $\Gamma\vdash t:A$, where
  $\Gamma = x_1:C_1,\ldots,x_n:C_n$, $\Delta = y_1:B_1,\ldots,y_m:B_m$, 
  $\theta:\{1,\ldots,n\}\to\{1,\ldots,m\}$ is an injection, 
  and $x_i^{C_i}=y_{\theta(i)}^{B_{\theta(i)}}$ for all $1\le i\le n$.
  By the induction hypothesis and $(b)$, the conclusion
  $t[y_{\theta (1)}/x_1,\ldots,y_{\theta (n)}/x_n][d_{i,\theta (1)}/y_{\theta (1)},\ldots,d_{i,\theta (n)}/y_{\theta (n)}]\vec{a_i}:\N$ 
  of $\weak$ is not total, where we have $\vec{d_i} = d_{i,1}\ldots d_{i,m}$.
  Then we define $e_{i+1}$ as the unique parent node of $e_i$ in the rule, and we
  also we define $\vec{d_{i+1}}$ and $\vec{a_{i+1}}$ by $d_{i,\theta (1)}\ldots d_{i,\theta (n)}$
  and $\vec{a_i}$, respectively. 
  We obtain (i), (ii), and (iii) for $i+1$, as expected.
  We also have (iv) since the connection, determined by $\theta $, from
  $(d_{i,1}\ldots d_{i,m};\vec{a_i})$ to 
  $(\vec{d_{i+1}};\vec{a_{i+1}}) = (d_{i,\theta (1)},\ldots d_{i,\theta (n)};\vec{a_i})$
  is trace compatible. 

\item
  The case of $\var$-rule, namely $\Label(\Pi,l_{i+1}) = \Gamma\vdash x_j:C_j$ for some $j$, 
cannot be, because $t_i = [x_j/d_j] = d_j$ is closed total by assumption on $\vec{d}$.

\item
  The case of $0$-rule, namely $\Label(\Pi,l_{i+1}) = \Gamma\vdash 0:\N$, 
cannot be. Indeed, $t_i = 0$ is total because $0$ is a numeral.

\item  
  The case of $\Succ$-rule, namely $\Label(\Pi,l_{i+1}) = 
  \Gamma\vdash t_i: \N = \Gamma\vdash \Succ(u): \N$ for some $u$ 
  is obtained from our assumptions on
  $\Gamma\vdash \Succ(u): \N$. In this case $\vec{a_i}$ is empty, $t_{i+1}=u$, and
  by the induction hypothesis $\Succ(u)[\vec{d_i}]):\N$ is not closed total.
  Then, by the definition of closed total, $u[\vec{d_i}] =t_{i+1}[\vec{d_i}] $ is not closed total. 
  We define $e_{i+1}=1$, 
  the index of the unique parent node of $l_{i+1}=(e_1, \ldots, e_n)$ in the $\Succ$-rule, and
  we also define $\vec{d_{i+1}}$ and $\vec{a_{i+1}}$ by $\vec{d_i}$ and the empty list, respectively. 
  We obtain (i), (ii), (iii), and (iv) for $i+1$, as expected.

\item
  The case of the $\apnotvar$-rule, namely 
  $\Label(\Pi,l_{i+1}) = \Gamma\vdash f[\vec{x}](u[\vec{x}]): \vec{A}\rightarrow\N$ 
  for some $f$, $u$
  is obtained from $\Gamma\vdash f[\vec{x}]: B \rightarrow \vec{A}\rightarrow\N$ 
  and $\Gamma\vdash u[\vec{x}]: B$. $u$ is not variable.
  By the induction hypothesis, $f[\vec{d_i}](u[\vec{d_i}])\vec{a_i}:\N$ is not total.
  We argue by case on the statement: \emph{$u[\vec{d_i}]:B$ is closed total}.

\begin{enumerate}
\item
  We first consider the subcase that \emph{$u[\vec{d_i}]:B$ is closed total}.
  We define $a':B$ by $a' = n\in\Num$ such that $u[\vec{d_i}] \safeReduces^* n$ if $B=\N$,
  by $a' = u[\vec{d_i}]$ otherwise. By lemma \ref{lem:total_value}.\ref{lem:total_value1}, $a'$ is a value.
  Then define $e_{i+1}=1$, the index of $f[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = a',\vec{a_i}$. 
  Using Lemma \ref{lem:total_value}.\ref{lem:total_value1}, \ref{lem:total_value}.\ref{lem:total_value2}
  we obtain (i), (ii), (iii) for $i+1$, as expected. 
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};a',\vec{a_i})$ is
  trace-compatible: all connected 
  $\N$-argument of $t_{i}=f(u)[\vec{x}]$ and $t_{i+1}[\vec{x}] = f[\vec{x}]$ are the same,
  because the only fresh argument of $f[\vec{x}]$ 
  is $a'$ and no argument of $f(u)[\vec{x}]$ is connected to it.
\item
  Next we consider the subcase that \emph{$u[\vec{d_i}]:B$ is not closed total}.
  By lemma \ref{lem:total_value}.\ref{lem:total_value3}
  there is a sequence of values $\vec{a'}$ such that $u[\vec{d_i}]\vec{a'}:\N$ is not total.
  Define $e_{i+1}=2$, the index of $u[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};\vec{a'})$ is
  trace compatible: all connected $\N$-argument of $t_{i}=f(u)[\vec{x}]$ and $t_{i+1}=u[\vec{x}]$ are 
  in $\vec{d_i}$ and therefore are the same.
 \end{enumerate}

\item
  The case of $\apvar$-rule, namely 
  $\Label(\Pi,l_{i+1}) 
    = 
   \Gamma,x^\N\vdash f[\vec{x}](x):  \vec{A}\rightarrow\N$ is obtained from
  $f[\vec{x}]:\Gamma\vdash N\rightarrow \vec{A} \rightarrow \N$. $x$ is a variable.
  By the induction hypothesis, $f[\vec{d'}]d\vec{a_i}:\N$ is not total,
  where $\vec{d_i} = \vec{d'},d$ and $d$ is the value of the variable $x^\N$.
  Define $e_{i+1}=1$ as the index of unique parent node of $l_{i+1}=(e_1,\ldots,e_i)$, and
  also define $\vec{d_{i+1}}$ by $\vec{d'}$ and define $\vec{a_{i+1}}$ by $d,\vec{a_i}$. 
  We obtain (i), (ii), and (iii) for $i+1$, as expected.
  We also have (iv) since the connection from
  $(\vec{d_i};\vec{a_i}) = (\vec{d'},d;\vec{a_i})$ to
  $(d_{i+1};\vec{a_{i+1}}) = (\vec{d'};d\vec{a_i})$
  is trace compatible: all connected $\N$-arguments in $\vec{d_{i}},\vec{a_{i}}$ and 
  $\vec{d_{i+1}},\vec{a_{i+1}}$ are the same.  
 The only difference between the two assignments
  is that the value $d$ of one variable $x$ of type $\N$ 
 in $t_i[\vec{x}]=f[\vec{x}](x)$ is duplicated to the value $d$ 
  of the first unnamed argument of $ f[\vec{x}]$. 

\item
  The case of $\lambda$-rule, namely
  $\Label(\Pi,l_{i+1}) = 
    \Gamma\vdash \lambda x^A.u[\vec{x},x] : A, \vec{A} \rightarrow \N$ is obtained from
  $t_{i+1}[\vec{x},x^A]:\Gamma,x^A\vdash \vec{A}\rightarrow\N$, 
  where $t_{i+1}[\vec{x},x]=u[\vec{x},x]$.
  By the induction hypothesis, $(\lambda x.(u[\vec{d_i},x]))a\vec{a'}:\N$ is not total,
  where $\vec{a_i} = a\vec{a'}$.
  Then, by Lemma~\ref{lem:total_value}, $t_{i+1}[\vec{d_i},a]\vec{a'}$ is not total. 
  We define $e_{i+1}=1$ as the index of unique parent node of $l_{i+1}=(e_1,\ldots,e_i)$,
  and we also define $\vec{d_{i+1}} = \vec{d_i},a$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i}) = (\vec{d_i};a\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i}a;
    \vec{a'})$ is trace-compatible: all connected argument in $\vec{d_{i}},\vec{a_{i}}$ and 
  $\vec{d_{i+1}},\vec{a_{i+1}}$ are the same. The only difference between the two assignments
  is that the value $d$ of the first unnamed argument of $t_i[\vec{x}]$ is moved to the value $d$
  of the last variable of type $\N$ of $t_{i+1}[\vec{x},x]=u[\vec{x},x]$.
  This is a kind of opposite of the movement we have in the $\apvar$.

\item  
  The case of $\cond$-rule, namely
  $\Label(\Pi,l_{i+1}) = \cond(f[\vec{x}],g[\vec{x},x]):
    \Gamma\vdash C\rightarrow \N,\vec{A}\rightarrow\N$
  is obtained from 
  $f[\vec{x}]:\Gamma\vdash \vec{A}\rightarrow\N$
  and
  $g[\vec{x}]:\Gamma\vdash \N,\vec{A}\rightarrow\N$. 
  By the induction hypothesis, $\cond(f[\vec{d_i}],g[\vec{d_i},x])m\vec{a'}:\N$ is not total,
  where $\vec{a_i} = m\vec{a'}$ and $m \in \Num$. We argue by cases on $m$.
\begin{enumerate}
\item
  We first consider the \emph{subcase $m=0$}.
  Define $e_{i+1}=1$ the index of parent node whose term is $f[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected. 
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})
 =(\vec{d_i};0\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i};\vec{a'})$
  is trace compatible: 
  each argument of $t_i$ is connected to some equal argument of $t_{i+1}[\vec{x}]=f[\vec{x}]$,
  the first argument of $t_i[\vec{x}]$ disappears but it is connected to no $\N$-argument in $f[\vec{x}]$.
\item
  Next we consider the \emph{subcase $m=\Succ(m')$}. 
  Define $e_{i+1}=2$ the index of the parent node whose term is $g[\vec{x}]$,
  and define $\vec{d_{i+1}} = \vec{d_i},m'$ and $\vec{a_{i+1}} = \vec{a'}$. 
  We obtain (i), (ii), (iii) for $i+1$, as expected.
  We also have (iv) since the connection from 
  $(\vec{d_i};\vec{a_i})
  =(\vec{d_i};\Succ(m'),\vec{a'})$ to $(\vec{d_{i+1}};\vec{a_{i+1}}) = (\vec{d_i},m';\vec{a'})$
  is trace compatible: 
  each argument of $t_i[\vec{x}]$ is connected to some equal argument of $t_{i+1}[\vec{x}]=g[\vec{x}]$,
  but for the first unnamend argument of $t_i[\vec{x}]$ 
   which is connected the first unnamend argument of $g[\vec{x}]$.
  This is fine because in the second premise of a $\cond$ 
  the trace progress. This requires that \emph{the value $m$ of the argument decreases by $1$}, 
  as indeed it is the case: the new value is $m'$.
\end{enumerate}

\end{enumerate}

  By the above construction, we have an infinite path $\pi = (e_1,e_2,\ldots)$ in $\universe{\Pi}$
 and a trace-compatible assignment, as we wished to show.

%  Since $\Pi$ satisfies the global trace condition, $\vec{e}$ contains a progressing trace
%  $(k_{m},k_{m+1},\ldots)$, where, for each $m\le i$, $k_i$ is an $\N$-argument of $t_i$, 
%  and $k_{i+1},t_{i+1}$ is the successor of $k_i,t_i$. 
%  Let $n_i$ be an numeral in $\vec{d_i},\vec{a_i}$ at index $k_i$ for each $m\le i$.
%  Then the sequence $(n_m,n_{m+1},\ldots$ decreases at each progressing point.
%  This means that it decreases infinitely many times
%  since $(k_{m},k_{m+1},\ldots)$ has infinitely many progressing point.
%  Finally we have a contradiction. 
  
\end{proof}

From this theorem we derive the weak normalization result: 
every closed term of type $\N$ is closed total, therefore by definition it reduces to some numeral for at least
one reduction path. 

\begin{corollary}
Assume  $t: \Gamma\vdash A$,
\begin {enumerate}
\item
 $t \in \GTC$ implies that $t$ is total.
\item
  For any closed $t:\N$, there is numeral $n\in\Num$ such that $t\safeReduces^* n$. 
\end{enumerate}
\end{corollary}



%\Daisuke{WN end}

\section{Uniqueness of normal form for closed terms of $\CTlambda$ of type $\N$}
\label{section-uniqueness-normal-form}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
\input{section-uniqueness-normal-form}


\section{Infinite reductions}
\label{section-infinite-reductions}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
\input{section-infinite-reductions}



\section{Normalization and Fairness}
\label{section-normalization-fairness}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
\input{section-normalization-fairness}


\section{Equivalence between cyclic and non-cyclic system $T$} 
\label{section-equivalence-cyclic-non-cyclic-T}
\bfColor{red}
{Incomplete section: uncomment the input command (below in the source code) to make this section visible}
\input{section-equivalence-cyclic-non-cyclic-T}

%
%\section{appendix}
%
%\begin{verbatim}
%
%To: kmr@is.sci.toho-u.ac.jp (Daisuke Kimura)
%Re: proof of Weak Normalization to an integer for CT-lambda
%Fri, 22 Mar 2024 08:25:57 +0100 
%
%    By the way, I re-checked the weak curry-howard proof, now i think that the proof 
%does not require the property p-->q, a-->b ==> p[a/x]-->q[b/x] and can be completed 
%with the notion of safe reduction.
%but in fact it would be more interesting to prove full church-rosser for Circular T-lambda, 
%as anupam does for his circular T.
%
%    About strong normalization, we can prove it for "safe" reductions, those inside no cond. 
%More in general, we know that we can have infinite reduction sequences, because we can 
%have infinitely many redexes. However, for any infinite reduction sequence sigma, I conjecture 
%we can prove a kind of stabilization of the term. After some reduction step, the term only 
%changes inside some cond nested k times. 
%
%    Namely, I conjecture that
%
%"for any cyclic lambda term t, any infinite reduction sequence (sigma(n)|n in N) with sigma(0)=t, 
%any k in N, there is a n0 in N such that for all n>=n0, the terms sigma(n) and sigma(n0)  
%coincide on all branches with at most k times cond."
%
%    Best, Stefano
%
%\end{verbatim}






\end{document}
